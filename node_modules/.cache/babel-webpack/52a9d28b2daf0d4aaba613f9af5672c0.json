{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericAndMarksCharsStr } from \"../regex-lib\";\nimport { MentionMatch } from \"../match/mention-match\"; // RegExp objects which are shared by all instances of MentionMatcher. These are\n// here to avoid re-instantiating the RegExp objects if `Autolinker.link()` is\n// called multiple times, thus instantiating MentionMatcher and its RegExp \n// objects each time (which is very expensive - see https://github.com/gregjacobs/Autolinker.js/issues/314). \n// See descriptions of the properties where they are used for details about them\n\nvar twitterRegex = new RegExp(\"@[_\" + alphaNumericAndMarksCharsStr + \"]{1,50}(?![_\" + alphaNumericAndMarksCharsStr + \"])\", 'g'); // lookahead used to make sure we don't match something above 50 characters\n\nvar instagramRegex = new RegExp(\"@[_.\" + alphaNumericAndMarksCharsStr + \"]{1,30}(?![_\" + alphaNumericAndMarksCharsStr + \"])\", 'g'); // lookahead used to make sure we don't match something above 30 characters\n\nvar soundcloudRegex = new RegExp(\"@[-_.\" + alphaNumericAndMarksCharsStr + \"]{1,50}(?![-_\" + alphaNumericAndMarksCharsStr + \"])\", 'g'); // lookahead used to make sure we don't match something above 50 characters\n\nvar nonWordCharRegex = new RegExp('[^' + alphaNumericAndMarksCharsStr + ']');\n/**\r\n * @class Autolinker.matcher.Mention\r\n * @extends Autolinker.matcher.Matcher\r\n *\r\n * Matcher to find/replace username matches in an input string.\r\n */\n\nvar MentionMatcher =\n/** @class */\n\n/*@__PURE__*/\nfunction (_super) {\n  tslib_1.__extends(MentionMatcher, _super);\n  /**\r\n   * @method constructor\r\n   * @param {Object} cfg The configuration properties for the Match instance,\r\n   *   specified in an Object (map).\r\n   */\n\n\n  function MentionMatcher(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    /**\r\n     * @cfg {'twitter'/'instagram'/'soundcloud'} protected\r\n     *\r\n     * The name of service to link @mentions to.\r\n     *\r\n     * Valid values are: 'twitter', 'instagram', or 'soundcloud'\r\n     */\n\n\n    _this.serviceName = 'twitter'; // default value just to get the above doc comment in the ES5 output and documentation generator\n\n    /**\r\n     * Hash of regular expression to match username handles. Example match:\r\n     *\r\n     *     @asdf\r\n     *\r\n     * @private\r\n     * @property {Object} matcherRegexes\r\n     */\n\n    _this.matcherRegexes = {\n      'twitter': twitterRegex,\n      'instagram': instagramRegex,\n      'soundcloud': soundcloudRegex\n    };\n    /**\r\n     * The regular expression to use to check the character before a username match to\r\n     * make sure we didn't accidentally match an email address.\r\n     *\r\n     * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\r\n     *\r\n     * @private\r\n     * @property {RegExp} nonWordCharRegex\r\n     */\n\n    _this.nonWordCharRegex = nonWordCharRegex;\n    _this.serviceName = cfg.serviceName;\n    return _this;\n  }\n  /**\r\n   * @inheritdoc\r\n   */\n\n\n  MentionMatcher.prototype.parseMatches = function (text) {\n    var serviceName = this.serviceName,\n        matcherRegex = this.matcherRegexes[this.serviceName],\n        nonWordCharRegex = this.nonWordCharRegex,\n        tagBuilder = this.tagBuilder,\n        matches = [],\n        match;\n\n    if (!matcherRegex) {\n      return matches;\n    }\n\n    while ((match = matcherRegex.exec(text)) !== null) {\n      var offset = match.index,\n          prevChar = text.charAt(offset - 1); // If we found the match at the beginning of the string, or we found the match\n      // and there is a whitespace char in front of it (meaning it is not an email\n      // address), then it is a username match.\n\n      if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n        var matchedText = match[0].replace(/\\.+$/g, ''),\n            // strip off trailing .\n        mention = matchedText.slice(1); // strip off the '@' character at the beginning\n\n        matches.push(new MentionMatch({\n          tagBuilder: tagBuilder,\n          matchedText: matchedText,\n          offset: offset,\n          serviceName: serviceName,\n          mention: mention\n        }));\n      }\n    }\n\n    return matches;\n  };\n\n  return MentionMatcher;\n}(Matcher);\n\nexport { MentionMatcher };","map":null,"metadata":{},"sourceType":"module"}