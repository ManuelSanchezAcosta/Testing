{"ast":null,"code":"import { fromCollectionRef } from '../observable/fromRef';\nimport { map, scan } from 'rxjs/operators';\nexport function docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(map(function (action) {\n    return action.payload.docChanges().map(function (change) {\n      return {\n        type: change.type,\n        payload: change\n      };\n    });\n  }));\n}\nexport function sortedChanges(query, events, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(map(function (changes) {\n    return changes.payload.docChanges();\n  }), scan(function (current, changes) {\n    return combineChanges(current, changes, events);\n  }, []), map(function (changes) {\n    return changes.map(function (c) {\n      return {\n        type: c.type,\n        payload: c\n      };\n    });\n  }));\n}\nexport function combineChanges(current, changes, events) {\n  changes.forEach(function (change) {\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\nexport function combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {} else {\n        combined.splice(change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        if (change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}","map":{"version":3,"sources":["../../../../../src/firestore/collection/changes.ts"],"names":[],"mappings":"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","sourcesContent":["import { fromCollectionRef } from '../observable/fromRef';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { map, scan } from 'rxjs/operators';\n\nimport { Query, DocumentChangeType, DocumentChange, DocumentChangeAction } from '../interfaces';\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(action =>\n        action.payload.docChanges()\n          .map(change => ({ type: change.type, payload: change } as DocumentChangeAction<T>))));\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nexport function sortedChanges<T>(query: Query, events: DocumentChangeType[], scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      map(changes => changes.payload.docChanges()),\n      scan((current, changes) => combineChanges(current, changes, events), []),\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if(events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch(change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        combined.splice(change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if(change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}