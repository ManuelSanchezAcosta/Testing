{"ast":null,"code":"import _slicedToArray from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject, Observable, merge, ReplaySubject, combineLatest, animationFrameScheduler } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from 'dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, NgZone, Renderer2, Output, EventEmitter, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, auditTime, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar DraggableHelper = /*@__PURE__*/function () {\n  var DraggableHelper = function DraggableHelper() {\n    _classCallCheck(this, DraggableHelper);\n\n    this.currentDrag = new Subject();\n  };\n\n  DraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n    return new (t || DraggableHelper)();\n  };\n\n  DraggableHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: DraggableHelper,\n    factory: DraggableHelper.ɵfac,\n    providedIn: 'root'\n  });\n  /** @nocollapse */\n\n  DraggableHelper.ngInjectableDef = defineInjectable({\n    factory: function DraggableHelper_Factory() {\n      return new DraggableHelper();\n    },\n    token: DraggableHelper,\n    providedIn: \"root\"\n  });\n  return DraggableHelper;\n}();\n\nvar DraggableScrollContainerDirective = /*@__PURE__*/function () {\n  var DraggableScrollContainerDirective = /*#__PURE__*/function () {\n    /**\n     * @hidden\n     * @param {?} elementRef\n     * @param {?} renderer\n     * @param {?} zone\n     */\n    function DraggableScrollContainerDirective(elementRef, renderer, zone) {\n      _classCallCheck(this, DraggableScrollContainerDirective);\n\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.zone = zone;\n      /**\n       * Trigger the DragStart after a long touch in scrollable container when true\n       */\n\n      this.activeLongPressDrag = false;\n      /**\n       * Configuration of a long touch\n       * Duration in ms of a long touch before activating DragStart\n       * Delta of the\n       */\n\n      this.longPressConfig = {\n        duration: 300,\n        delta: 30\n      };\n      this.cancelledScroll = false;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DraggableScrollContainerDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this = this;\n\n        this.zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this.renderer.listen(_this.elementRef.nativeElement, 'touchmove',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            if (_this.cancelledScroll && event.cancelable) {\n              event.preventDefault();\n            }\n          });\n        });\n      }\n      /**\n       * @hidden\n       * @return {?}\n       */\n\n    }, {\n      key: \"disableScroll\",\n      value: function disableScroll() {\n        this.cancelledScroll = true;\n        this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'hidden');\n      }\n      /**\n       * @hidden\n       * @return {?}\n       */\n\n    }, {\n      key: \"enableScroll\",\n      value: function enableScroll() {\n        this.cancelledScroll = false;\n        this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'auto');\n      }\n      /**\n       * @hidden\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasScrollbar\",\n      value: function hasScrollbar() {\n        /** @type {?} */\n        var containerHasHorizontalScroll = this.elementRef.nativeElement.scrollWidth - this.elementRef.nativeElement.clientWidth > 0;\n        /** @type {?} */\n\n        var containerHasVerticalScroll = this.elementRef.nativeElement.scrollHeight - this.elementRef.nativeElement.clientHeight > 0;\n        return containerHasHorizontalScroll || containerHasVerticalScroll;\n      }\n    }]);\n\n    return DraggableScrollContainerDirective;\n  }();\n\n  DraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n    return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  DraggableScrollContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: DraggableScrollContainerDirective,\n    selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n    inputs: {\n      activeLongPressDrag: \"activeLongPressDrag\",\n      longPressConfig: \"longPressConfig\"\n    }\n  });\n  return DraggableScrollContainerDirective;\n}();\n\nvar DraggableDirective = /*@__PURE__*/function () {\n  var DraggableDirective = /*#__PURE__*/function () {\n    /**\n     * @hidden\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} vcr\n     * @param {?} scrollContainer\n     * @param {?} document\n     */\n    function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n      _classCallCheck(this, DraggableDirective);\n\n      this.element = element;\n      this.renderer = renderer;\n      this.draggableHelper = draggableHelper;\n      this.zone = zone;\n      this.vcr = vcr;\n      this.scrollContainer = scrollContainer;\n      this.document = document;\n      /**\n       * The axis along which the element is draggable\n       */\n\n      this.dragAxis = {\n        x: true,\n        y: true\n      };\n      /**\n       * Snap all drags to an x / y grid\n       */\n\n      this.dragSnapGrid = {};\n      /**\n       * Show a ghost element that shows the drag when dragging\n       */\n\n      this.ghostDragEnabled = true;\n      /**\n       * Show the original element when ghostDragEnabled is true\n       */\n\n      this.showOriginalElementWhileDragging = false;\n      /**\n       * The cursor to use when hovering over a draggable element\n       */\n\n      this.dragCursor = '';\n      /**\n       * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n       */\n\n      this.dragPointerDown = new EventEmitter();\n      /**\n       * Called when the element has started to be dragged.\n       * Only called after at least one mouse or touch move event.\n       * If you call $event.cancelDrag$.emit() it will cancel the current drag\n       */\n\n      this.dragStart = new EventEmitter();\n      /**\n       * Called after the ghost element has been created\n       */\n\n      this.ghostElementCreated = new EventEmitter();\n      /**\n       * Called when the element is being dragged\n       */\n\n      this.dragging = new EventEmitter();\n      /**\n       * Called after the element is dragged\n       */\n\n      this.dragEnd = new EventEmitter();\n      /**\n       * @hidden\n       */\n\n      this.pointerDown$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.pointerMove$ = new Subject();\n      /**\n       * @hidden\n       */\n\n      this.pointerUp$ = new Subject();\n      this.eventListenerSubscriptions = {};\n      this.destroy$ = new Subject();\n      this.timeLongPress = {\n        timerBegin: 0,\n        timerEnd: 0\n      };\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DraggableDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this2 = this;\n\n        this.checkEventListeners();\n        /** @type {?} */\n\n        var pointerDragged$ = this.pointerDown$.pipe(filter(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this2.canDrag();\n        }), mergeMap(\n        /**\n        * @param {?} pointerDownEvent\n        * @return {?}\n        */\n        function (pointerDownEvent) {\n          // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n          // stop mouse events propagating up the chain\n          if (pointerDownEvent.event.stopPropagation && !_this2.scrollContainer) {\n            pointerDownEvent.event.stopPropagation();\n          }\n          /** @type {?} */\n\n\n          var startScrollPosition = _this2.getScrollPosition();\n          /** @type {?} */\n\n\n          var scrollContainerScroll$ = new Observable(\n          /**\n          * @param {?} observer\n          * @return {?}\n          */\n\n          /**\n          * @param {?} observer\n          * @return {?}\n          */\n          function (observer) {\n            /** @type {?} */\n            var scrollContainer = _this2.scrollContainer ? _this2.scrollContainer.elementRef.nativeElement : 'window';\n            return _this2.renderer.listen(scrollContainer, 'scroll',\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            function (e) {\n              return observer.next(e);\n            });\n          }).pipe(startWith(startScrollPosition), map(\n          /**\n          * @return {?}\n          */\n          function () {\n            return _this2.getScrollPosition();\n          }));\n          /** @type {?} */\n\n          var currentDrag$ = new Subject();\n          /** @type {?} */\n\n          var cancelDrag$ = new ReplaySubject();\n\n          _this2.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.dragPointerDown.next({\n              x: 0,\n              y: 0\n            });\n          });\n          /** @type {?} */\n\n\n          var dragComplete$ = merge(_this2.pointerUp$, _this2.pointerDown$, cancelDrag$, _this2.destroy$).pipe(share());\n          /** @type {?} */\n\n          var pointerMove = combineLatest([_this2.pointerMove$, scrollContainerScroll$]).pipe(map(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                pointerMoveEvent = _ref2[0],\n                scroll = _ref2[1];\n\n            return {\n              currentDrag$: currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top\n            };\n          }), map(\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n          function (moveData) {\n            if (_this2.dragSnapGrid.x) {\n              moveData.transformX = Math.round(moveData.transformX / _this2.dragSnapGrid.x) * _this2.dragSnapGrid.x;\n            }\n\n            if (_this2.dragSnapGrid.y) {\n              moveData.transformY = Math.round(moveData.transformY / _this2.dragSnapGrid.y) * _this2.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }), map(\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n          function (moveData) {\n            if (!_this2.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!_this2.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }), map(\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n\n          /**\n          * @param {?} moveData\n          * @return {?}\n          */\n          function (moveData) {\n            /** @type {?} */\n            var scrollX = moveData.scrollLeft - startScrollPosition.left;\n            /** @type {?} */\n\n            var scrollY = moveData.scrollTop - startScrollPosition.top;\n            return Object.assign({}, moveData, {\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY\n            });\n          }), filter(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref3) {\n            var x = _ref3.x,\n                y = _ref3.y,\n                transformX = _ref3.transformX,\n                transformY = _ref3.transformY;\n            return !_this2.validateDrag || _this2.validateDrag({\n              x: x,\n              y: y,\n              transform: {\n                x: transformX,\n                y: transformY\n              }\n            });\n          }), takeUntil(dragComplete$), share());\n          /** @type {?} */\n\n          var dragStarted$ = pointerMove.pipe(take(1), share());\n          /** @type {?} */\n\n          var dragEnded$ = pointerMove.pipe(takeLast(1), share());\n          dragStarted$.subscribe(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref4) {\n            var clientX = _ref4.clientX,\n                clientY = _ref4.clientY,\n                x = _ref4.x,\n                y = _ref4.y;\n\n            _this2.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this2.dragStart.next({\n                cancelDrag$: cancelDrag$\n              });\n            });\n\n            _this2.scroller = autoScroll([_this2.scrollContainer ? _this2.scrollContainer.elementRef.nativeElement : _this2.document.defaultView], {\n              margin: 20,\n\n              /**\n               * @return {?}\n               */\n              autoScroll: function autoScroll() {\n                return true;\n              }\n            });\n\n            _this2.renderer.addClass(_this2.element.nativeElement, _this2.dragActiveClass);\n\n            if (_this2.ghostDragEnabled) {\n              /** @type {?} */\n              var rect = _this2.element.nativeElement.getBoundingClientRect();\n              /** @type {?} */\n\n\n              var clone =\n              /** @type {?} */\n              _this2.element.nativeElement.cloneNode(true);\n\n              if (!_this2.showOriginalElementWhileDragging) {\n                _this2.renderer.setStyle(_this2.element.nativeElement, 'visibility', 'hidden');\n              }\n\n              if (_this2.ghostElementAppendTo) {\n                _this2.ghostElementAppendTo.appendChild(clone);\n              } else {\n                /** @type {?} */\n                _this2.element.nativeElement.parentNode.insertBefore(clone, _this2.element.nativeElement.nextSibling);\n              }\n\n              _this2.ghostElement = clone;\n              document.body.style.cursor = _this2.dragCursor;\n\n              _this2.setElementStyles(clone, {\n                position: 'fixed',\n                top: \"\".concat(rect.top, \"px\"),\n                left: \"\".concat(rect.left, \"px\"),\n                width: \"\".concat(rect.width, \"px\"),\n                height: \"\".concat(rect.height, \"px\"),\n                cursor: _this2.dragCursor,\n                margin: '0',\n                willChange: 'transform',\n                pointerEvents: 'none'\n              });\n\n              if (_this2.ghostElementTemplate) {\n                /** @type {?} */\n                var viewRef = _this2.vcr.createEmbeddedView(_this2.ghostElementTemplate);\n\n                clone.innerHTML = '';\n                viewRef.rootNodes.filter(\n                /**\n                * @param {?} node\n                * @return {?}\n                */\n\n                /**\n                * @param {?} node\n                * @return {?}\n                */\n                function (node) {\n                  return node instanceof Node;\n                }).forEach(\n                /**\n                * @param {?} node\n                * @return {?}\n                */\n\n                /**\n                * @param {?} node\n                * @return {?}\n                */\n                function (node) {\n                  clone.appendChild(node);\n                });\n                dragEnded$.subscribe(\n                /**\n                * @return {?}\n                */\n                function () {\n                  _this2.vcr.remove(_this2.vcr.indexOf(viewRef));\n                });\n              }\n\n              _this2.zone.run(\n              /**\n              * @return {?}\n              */\n              function () {\n                _this2.ghostElementCreated.emit({\n                  clientX: clientX - x,\n                  clientY: clientY - y,\n                  element: clone\n                });\n              });\n\n              dragEnded$.subscribe(\n              /**\n              * @return {?}\n              */\n              function () {\n                /** @type {?} */\n                clone.parentElement.removeChild(clone);\n                _this2.ghostElement = null;\n\n                _this2.renderer.setStyle(_this2.element.nativeElement, 'visibility', '');\n              });\n            }\n\n            _this2.draggableHelper.currentDrag.next(currentDrag$);\n          });\n          dragEnded$.pipe(mergeMap(\n          /**\n          * @param {?} dragEndData\n          * @return {?}\n          */\n\n          /**\n          * @param {?} dragEndData\n          * @return {?}\n          */\n          function (dragEndData) {\n            /** @type {?} */\n            var dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n            /**\n            * @param {?} calledCount\n            * @return {?}\n            */\n\n            /**\n            * @param {?} calledCount\n            * @return {?}\n            */\n            function (calledCount) {\n              return Object.assign({}, dragEndData, {\n                dragCancelled: calledCount > 0\n              });\n            }));\n            cancelDrag$.complete();\n            return dragEndData$;\n          })).subscribe(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref5) {\n            var x = _ref5.x,\n                y = _ref5.y,\n                dragCancelled = _ref5.dragCancelled;\n\n            _this2.scroller.destroy();\n\n            _this2.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this2.dragEnd.next({\n                x: x,\n                y: y,\n                dragCancelled: dragCancelled\n              });\n            });\n\n            _this2.renderer.removeClass(_this2.element.nativeElement, _this2.dragActiveClass);\n\n            currentDrag$.complete();\n          });\n          /** @type {?} */\n\n          var selectionStart$ = new Observable(\n          /**\n          * @param {?} observer\n          * @return {?}\n          */\n\n          /**\n          * @param {?} observer\n          * @return {?}\n          */\n          function (observer) {\n            return _this2.renderer.listen('document', 'selectstart',\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n\n            /**\n            * @param {?} e\n            * @return {?}\n            */\n            function (e) {\n              return observer.next(e);\n            });\n          }); // hack to prevent text getting selected in safari while dragging\n\n          selectionStart$.pipe(takeUntil(merge(dragComplete$, dragEnded$))).subscribe(\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            event.preventDefault();\n          });\n          return pointerMove;\n        }), share());\n        merge(pointerDragged$.pipe(take(1), map(\n        /**\n        * @param {?} value\n        * @return {?}\n        */\n\n        /**\n        * @param {?} value\n        * @return {?}\n        */\n        function (value) {\n          return [, value];\n        })), pointerDragged$.pipe(pairwise())).pipe(filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n              previous = _ref7[0],\n              next = _ref7[1];\n\n          if (!previous) {\n            return true;\n          }\n\n          return previous.x !== next.x || previous.y !== next.y;\n        }), map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref8) {\n          var _ref9 = _slicedToArray(_ref8, 2),\n              previous = _ref9[0],\n              next = _ref9[1];\n\n          return next;\n        }), auditTime(0, animationFrameScheduler)).subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref10) {\n          var x = _ref10.x,\n              y = _ref10.y,\n              currentDrag$ = _ref10.currentDrag$,\n              clientX = _ref10.clientX,\n              clientY = _ref10.clientY,\n              transformX = _ref10.transformX,\n              transformY = _ref10.transformY;\n\n          _this2.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.dragging.next({\n              x: x,\n              y: y\n            });\n          });\n\n          if (_this2.ghostElement) {\n            /** @type {?} */\n            var transform = \"translate3d(\".concat(transformX, \"px, \").concat(transformY, \"px, 0px)\");\n\n            _this2.setElementStyles(_this2.ghostElement, {\n              transform: transform,\n              '-webkit-transform': transform,\n              '-ms-transform': transform,\n              '-moz-transform': transform,\n              '-o-transform': transform\n            });\n          }\n\n          currentDrag$.next({\n            clientX: clientX,\n            clientY: clientY,\n            dropData: _this2.dropData\n          });\n        });\n      }\n      /**\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        if (changes.dragAxis) {\n          this.checkEventListeners();\n        }\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.unsubscribeEventListeners();\n        this.pointerDown$.complete();\n        this.pointerMove$.complete();\n        this.pointerUp$.complete();\n        this.destroy$.next();\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"checkEventListeners\",\n      value: function checkEventListeners() {\n        var _this3 = this;\n\n        /** @type {?} */\n        var canDrag = this.canDrag();\n        /** @type {?} */\n\n        var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n        if (canDrag && !hasEventListeners) {\n          this.zone.runOutsideAngular(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this3.eventListenerSubscriptions.mousedown = _this3.renderer.listen(_this3.element.nativeElement, 'mousedown',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this3.onMouseDown(event);\n            });\n            _this3.eventListenerSubscriptions.mouseup = _this3.renderer.listen('document', 'mouseup',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this3.onMouseUp(event);\n            });\n            _this3.eventListenerSubscriptions.touchstart = _this3.renderer.listen(_this3.element.nativeElement, 'touchstart',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this3.onTouchStart(event);\n            });\n            _this3.eventListenerSubscriptions.touchend = _this3.renderer.listen('document', 'touchend',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this3.onTouchEnd(event);\n            });\n            _this3.eventListenerSubscriptions.touchcancel = _this3.renderer.listen('document', 'touchcancel',\n            /**\n            * @param {?} event\n            * @return {?}\n            */\n            function (event) {\n              _this3.onTouchEnd(event);\n            });\n            _this3.eventListenerSubscriptions.mouseenter = _this3.renderer.listen(_this3.element.nativeElement, 'mouseenter',\n            /**\n            * @return {?}\n            */\n            function () {\n              _this3.onMouseEnter();\n            });\n            _this3.eventListenerSubscriptions.mouseleave = _this3.renderer.listen(_this3.element.nativeElement, 'mouseleave',\n            /**\n            * @return {?}\n            */\n            function () {\n              _this3.onMouseLeave();\n            });\n          });\n        } else if (!canDrag && hasEventListeners) {\n          this.unsubscribeEventListeners();\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseDown\",\n      value: function onMouseDown(event) {\n        var _this4 = this;\n\n        if (!this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n          /**\n          * @param {?} mouseMoveEvent\n          * @return {?}\n          */\n          function (mouseMoveEvent) {\n            _this4.pointerMove$.next({\n              event: mouseMoveEvent,\n              clientX: mouseMoveEvent.clientX,\n              clientY: mouseMoveEvent.clientY\n            });\n          });\n        }\n\n        this.pointerDown$.next({\n          event: event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseUp\",\n      value: function onMouseUp(event) {\n        if (this.eventListenerSubscriptions.mousemove) {\n          this.eventListenerSubscriptions.mousemove();\n          delete this.eventListenerSubscriptions.mousemove;\n        }\n\n        this.pointerUp$.next({\n          event: event,\n          clientX: event.clientX,\n          clientY: event.clientY\n        });\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onTouchStart\",\n      value: function onTouchStart(event) {\n        var _this5 = this;\n\n        if (!this.scrollContainer) {\n          try {\n            event.preventDefault();\n          } catch (e) {}\n        }\n        /** @type {?} */\n\n\n        var hasContainerScrollbar;\n        /** @type {?} */\n\n        var startScrollPosition;\n        /** @type {?} */\n\n        var isDragActivated;\n\n        if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n          this.timeLongPress.timerBegin = Date.now();\n          isDragActivated = false;\n          hasContainerScrollbar = this.scrollContainer.hasScrollbar();\n          startScrollPosition = this.getScrollPosition();\n        }\n\n        if (!this.eventListenerSubscriptions.touchmove) {\n          this.eventListenerSubscriptions.touchmove = this.renderer.listen('document', 'touchmove',\n          /**\n          * @param {?} touchMoveEvent\n          * @return {?}\n          */\n          function (touchMoveEvent) {\n            if (_this5.scrollContainer && _this5.scrollContainer.activeLongPressDrag && !isDragActivated && hasContainerScrollbar) {\n              isDragActivated = _this5.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n            }\n\n            if (!_this5.scrollContainer || !_this5.scrollContainer.activeLongPressDrag || !hasContainerScrollbar || isDragActivated) {\n              _this5.pointerMove$.next({\n                event: touchMoveEvent,\n                clientX: touchMoveEvent.targetTouches[0].clientX,\n                clientY: touchMoveEvent.targetTouches[0].clientY\n              });\n            }\n          });\n        }\n\n        this.pointerDown$.next({\n          event: event,\n          clientX: event.touches[0].clientX,\n          clientY: event.touches[0].clientY\n        });\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onTouchEnd\",\n      value: function onTouchEnd(event) {\n        if (this.eventListenerSubscriptions.touchmove) {\n          this.eventListenerSubscriptions.touchmove();\n          delete this.eventListenerSubscriptions.touchmove;\n\n          if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n            this.scrollContainer.enableScroll();\n          }\n        }\n\n        this.pointerUp$.next({\n          event: event,\n          clientX: event.changedTouches[0].clientX,\n          clientY: event.changedTouches[0].clientY\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseEnter\",\n      value: function onMouseEnter() {\n        this.setCursor(this.dragCursor);\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMouseLeave\",\n      value: function onMouseLeave() {\n        this.setCursor('');\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"canDrag\",\n      value: function canDrag() {\n        return this.dragAxis.x || this.dragAxis.y;\n      }\n      /**\n       * @private\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"setCursor\",\n      value: function setCursor(value) {\n        if (!this.eventListenerSubscriptions.mousemove) {\n          this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n        }\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"unsubscribeEventListeners\",\n      value: function unsubscribeEventListeners() {\n        var _this6 = this;\n\n        Object.keys(this.eventListenerSubscriptions).forEach(\n        /**\n        * @param {?} type\n        * @return {?}\n        */\n\n        /**\n        * @param {?} type\n        * @return {?}\n        */\n        function (type) {\n          /** @type {?} */\n          _this6.eventListenerSubscriptions[type]();\n\n          delete\n          /** @type {?} */\n          _this6.eventListenerSubscriptions[type];\n        });\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @param {?} styles\n       * @return {?}\n       */\n\n    }, {\n      key: \"setElementStyles\",\n      value: function setElementStyles(element, styles) {\n        var _this7 = this;\n\n        Object.keys(styles).forEach(\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n        function (key) {\n          _this7.renderer.setStyle(element, key, styles[key]);\n        });\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"getScrollPosition\",\n      value: function getScrollPosition() {\n        if (this.scrollContainer) {\n          return {\n            top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n            left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n          };\n        } else {\n          return {\n            top: window.pageYOffset || document.documentElement.scrollTop,\n            left: window.pageXOffset || document.documentElement.scrollLeft\n          };\n        }\n      }\n      /**\n       * @private\n       * @param {?} event\n       * @param {?} touchMoveEvent\n       * @param {?} startScrollPosition\n       * @return {?}\n       */\n\n    }, {\n      key: \"shouldBeginDrag\",\n      value: function shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n        /** @type {?} */\n        var moveScrollPosition = this.getScrollPosition();\n        /** @type {?} */\n\n        var deltaScroll = {\n          top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n          left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n        };\n        /** @type {?} */\n\n        var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n        /** @type {?} */\n\n        var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n        /** @type {?} */\n\n        var deltaTotal = deltaX + deltaY;\n\n        if (deltaTotal > this.scrollContainer.longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n          this.timeLongPress.timerBegin = Date.now();\n        }\n\n        this.timeLongPress.timerEnd = Date.now();\n        /** @type {?} */\n\n        var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n        if (duration >= this.scrollContainer.longPressConfig.duration) {\n          this.scrollContainer.disableScroll();\n          return true;\n        }\n\n        return false;\n      }\n    }]);\n\n    return DraggableDirective;\n  }();\n\n  DraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n    return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  DraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: DraggableDirective,\n    selectors: [[\"\", \"mwlDraggable\", \"\"]],\n    inputs: {\n      dragAxis: \"dragAxis\",\n      dragSnapGrid: \"dragSnapGrid\",\n      ghostDragEnabled: \"ghostDragEnabled\",\n      showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n      dragCursor: \"dragCursor\",\n      dropData: \"dropData\",\n      validateDrag: \"validateDrag\",\n      dragActiveClass: \"dragActiveClass\",\n      ghostElementAppendTo: \"ghostElementAppendTo\",\n      ghostElementTemplate: \"ghostElementTemplate\"\n    },\n    outputs: {\n      dragPointerDown: \"dragPointerDown\",\n      dragStart: \"dragStart\",\n      ghostElementCreated: \"ghostElementCreated\",\n      dragging: \"dragging\",\n      dragEnd: \"dragEnd\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return DraggableDirective;\n}();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nvar DroppableDirective = /*@__PURE__*/function () {\n  var DroppableDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} element\n     * @param {?} draggableHelper\n     * @param {?} zone\n     * @param {?} renderer\n     * @param {?} scrollContainer\n     */\n    function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n      _classCallCheck(this, DroppableDirective);\n\n      this.element = element;\n      this.draggableHelper = draggableHelper;\n      this.zone = zone;\n      this.renderer = renderer;\n      this.scrollContainer = scrollContainer;\n      /**\n       * Called when a draggable element starts overlapping the element\n       */\n\n      this.dragEnter = new EventEmitter();\n      /**\n       * Called when a draggable element stops overlapping the element\n       */\n\n      this.dragLeave = new EventEmitter();\n      /**\n       * Called when a draggable element is moved over the element\n       */\n\n      this.dragOver = new EventEmitter();\n      /**\n       * Called when a draggable element is dropped on this element\n       */\n\n      this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(DroppableDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this8 = this;\n\n        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n        /**\n        * @param {?} drag$\n        * @return {?}\n        */\n\n        /**\n        * @param {?} drag$\n        * @return {?}\n        */\n        function (drag$) {\n          _this8.renderer.addClass(_this8.element.nativeElement, _this8.dragActiveClass);\n          /** @type {?} */\n\n\n          var droppableElement = {\n            updateCache: true\n          };\n          /** @type {?} */\n\n          var deregisterScrollListener = _this8.renderer.listen(_this8.scrollContainer ? _this8.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n          /**\n          * @return {?}\n          */\n          function () {\n            droppableElement.updateCache = true;\n          });\n          /** @type {?} */\n\n\n          var currentDragDropData;\n          /** @type {?} */\n\n          var overlaps$ = drag$.pipe(map(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref11) {\n            var clientX = _ref11.clientX,\n                clientY = _ref11.clientY,\n                dropData = _ref11.dropData;\n            currentDragDropData = dropData;\n\n            if (droppableElement.updateCache) {\n              droppableElement.rect = _this8.element.nativeElement.getBoundingClientRect();\n\n              if (_this8.scrollContainer) {\n                droppableElement.scrollContainerRect = _this8.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n\n              droppableElement.updateCache = false;\n            }\n            /** @type {?} */\n\n\n            var isWithinElement = isCoordinateWithinRectangle(clientX, clientY,\n            /** @type {?} */\n            droppableElement.rect);\n\n            if (droppableElement.scrollContainerRect) {\n              return isWithinElement && isCoordinateWithinRectangle(clientX, clientY,\n              /** @type {?} */\n              droppableElement.scrollContainerRect);\n            } else {\n              return isWithinElement;\n            }\n          }));\n          /** @type {?} */\n\n          var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n          /** @type {?} */\n\n          var dragOverActive;\n          overlapsChanged$.pipe(filter(\n          /**\n          * @param {?} overlapsNow\n          * @return {?}\n          */\n\n          /**\n          * @param {?} overlapsNow\n          * @return {?}\n          */\n          function (overlapsNow) {\n            return overlapsNow;\n          })).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            dragOverActive = true;\n\n            _this8.renderer.addClass(_this8.element.nativeElement, _this8.dragOverClass);\n\n            _this8.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this8.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n          overlaps$.pipe(filter(\n          /**\n          * @param {?} overlapsNow\n          * @return {?}\n          */\n\n          /**\n          * @param {?} overlapsNow\n          * @return {?}\n          */\n          function (overlapsNow) {\n            return overlapsNow;\n          })).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this8.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this8.dragOver.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n          overlapsChanged$.pipe(pairwise(), filter(\n          /**\n          * @param {?} __0\n          * @return {?}\n          */\n          function (_ref12) {\n            var _ref13 = _slicedToArray(_ref12, 2),\n                didOverlap = _ref13[0],\n                overlapsNow = _ref13[1];\n\n            return didOverlap && !overlapsNow;\n          })).subscribe(\n          /**\n          * @return {?}\n          */\n          function () {\n            dragOverActive = false;\n\n            _this8.renderer.removeClass(_this8.element.nativeElement, _this8.dragOverClass);\n\n            _this8.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this8.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n          drag$.subscribe({\n            complete:\n            /**\n            * @return {?}\n            */\n            function complete() {\n              deregisterScrollListener();\n\n              _this8.renderer.removeClass(_this8.element.nativeElement, _this8.dragActiveClass);\n\n              if (dragOverActive) {\n                _this8.renderer.removeClass(_this8.element.nativeElement, _this8.dragOverClass);\n\n                _this8.zone.run(\n                /**\n                * @return {?}\n                */\n                function () {\n                  _this8.drop.next({\n                    dropData: currentDragDropData\n                  });\n                });\n              }\n            }\n          });\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        if (this.currentDragSubscription) {\n          this.currentDragSubscription.unsubscribe();\n        }\n      }\n    }]);\n\n    return DroppableDirective;\n  }();\n\n  DroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n    return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n  };\n\n  DroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: DroppableDirective,\n    selectors: [[\"\", \"mwlDroppable\", \"\"]],\n    inputs: {\n      dragOverClass: \"dragOverClass\",\n      dragActiveClass: \"dragActiveClass\"\n    },\n    outputs: {\n      dragEnter: \"dragEnter\",\n      dragLeave: \"dragLeave\",\n      dragOver: \"dragOver\",\n      drop: \"drop\"\n    }\n  });\n  return DroppableDirective;\n}();\n\nvar DragAndDropModule = /*@__PURE__*/function () {\n  var DragAndDropModule = function DragAndDropModule() {\n    _classCallCheck(this, DragAndDropModule);\n  };\n\n  DragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: DragAndDropModule\n  });\n  DragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function DragAndDropModule_Factory(t) {\n      return new (t || DragAndDropModule)();\n    }\n  });\n  return DragAndDropModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };","map":null,"metadata":{},"sourceType":"module"}