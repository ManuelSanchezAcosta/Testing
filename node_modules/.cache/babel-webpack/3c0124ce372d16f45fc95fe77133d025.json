{"ast":null,"code":"import _toConsumableArray from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { InjectionToken } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, queueScheduler, asyncScheduler } from 'rxjs';\nimport { subscribeOn, observeOn, tap } from 'rxjs/operators';\nexport var RealtimeDatabaseURL = new InjectionToken('angularfire2.realtimeDatabaseURL');\nexport var DATABASE_URL = RealtimeDatabaseURL;\n\nfunction noop() {}\n\nexport var ɵZoneScheduler = /*#__PURE__*/function () {\n  function ɵZoneScheduler(zone) {\n    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : queueScheduler;\n\n    _classCallCheck(this, ɵZoneScheduler);\n\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n\n  _createClass(ɵZoneScheduler, [{\n    key: \"now\",\n    value: function now() {\n      return this.delegate.now();\n    }\n  }, {\n    key: \"schedule\",\n    value: function schedule(work, delay, state) {\n      var targetZone = this.zone;\n\n      var workInZone = function workInZone(state) {\n        var _this = this;\n\n        targetZone.runGuarded(function () {\n          work.apply(_this, [state]);\n        });\n      };\n\n      return this.delegate.schedule(workInZone, delay, state);\n    }\n  }]);\n\n  return ɵZoneScheduler;\n}();\nexport var ɵBlockUntilFirstOperator = /*#__PURE__*/function () {\n  function ɵBlockUntilFirstOperator(zone) {\n    _classCallCheck(this, ɵBlockUntilFirstOperator);\n\n    this.zone = zone;\n    this.task = null;\n  }\n\n  _createClass(ɵBlockUntilFirstOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      var unscheduleTask = this.unscheduleTask.bind(this);\n      this.task = this.zone.run(function () {\n        return Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n      });\n      return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);\n    }\n  }, {\n    key: \"unscheduleTask\",\n    value: function unscheduleTask() {\n      if (this.task != null && this.task.state === 'scheduled') {\n        this.task.invoke();\n        this.task = null;\n      }\n    }\n  }]);\n\n  return ɵBlockUntilFirstOperator;\n}();\nexport var ɵAngularFireSchedulers = function ɵAngularFireSchedulers(ngZone) {\n  _classCallCheck(this, ɵAngularFireSchedulers);\n\n  this.ngZone = ngZone;\n  this.outsideAngular = ngZone.runOutsideAngular(function () {\n    return new ɵZoneScheduler(Zone.current);\n  });\n  this.insideAngular = ngZone.run(function () {\n    return new ɵZoneScheduler(Zone.current, asyncScheduler);\n  });\n};\nexport function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {\n  return function keepUnstableUntilFirst(obs$) {\n    if (isPlatformServer(platformId)) {\n      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n    }\n\n    return obs$.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n  };\n}\nexport var runOutsideAngular = function runOutsideAngular(zone) {\n  return function (obs$) {\n    return new Observable(function (subscriber) {\n      return zone.runOutsideAngular(function () {\n        runInZone(zone)(obs$).subscribe(subscriber);\n      });\n    });\n  };\n};\nexport var runInZone = function runInZone(zone) {\n  return function (obs$) {\n    return new Observable(function (subscriber) {\n      return obs$.subscribe(function (value) {\n        return zone.run(function () {\n          return subscriber.next(value);\n        });\n      }, function (error) {\n        return zone.run(function () {\n          return subscriber.error(error);\n        });\n      }, function () {\n        return zone.run(function () {\n          return subscriber.complete();\n        });\n      });\n    });\n  };\n};\nexport var FirebaseZoneScheduler = /*#__PURE__*/function () {\n  function FirebaseZoneScheduler(zone, platformId) {\n    _classCallCheck(this, FirebaseZoneScheduler);\n\n    this.zone = zone;\n    this.platformId = platformId;\n  }\n\n  _createClass(FirebaseZoneScheduler, [{\n    key: \"schedule\",\n    value: function schedule() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.zone.runGuarded(function () {\n        return queueScheduler.schedule.apply(queueScheduler, args);\n      });\n    }\n  }, {\n    key: \"keepUnstableUntilFirst\",\n    value: function keepUnstableUntilFirst(obs$) {\n      if (isPlatformServer(this.platformId)) {\n        return new Observable(function (subscriber) {\n          var noop = function noop() {};\n\n          var task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n          obs$.subscribe(function (next) {\n            if (task.state === 'scheduled') {\n              task.invoke();\n            }\n\n            ;\n            subscriber.next(next);\n          }, function (error) {\n            if (task.state === 'scheduled') {\n              task.invoke();\n            }\n\n            subscriber.error(error);\n          }, function () {\n            if (task.state === 'scheduled') {\n              task.invoke();\n            }\n\n            subscriber.complete();\n          });\n        });\n      } else {\n        return obs$;\n      }\n    }\n  }, {\n    key: \"runOutsideAngular\",\n    value: function runOutsideAngular(obs$) {\n      var _this2 = this;\n\n      return new Observable(function (subscriber) {\n        return _this2.zone.runOutsideAngular(function () {\n          return obs$.subscribe(function (value) {\n            return _this2.zone.run(function () {\n              return subscriber.next(value);\n            });\n          }, function (error) {\n            return _this2.zone.run(function () {\n              return subscriber.error(error);\n            });\n          }, function () {\n            return _this2.zone.run(function () {\n              return subscriber.complete();\n            });\n          });\n        });\n      });\n    }\n  }]);\n\n  return FirebaseZoneScheduler;\n}();\nvar noopFunctions = ['ngOnDestroy'];\nexport var ɵlazySDKProxy = function ɵlazySDKProxy(klass, observable, zone) {\n  return new Proxy(klass, {\n    get: function get(_, name) {\n      return zone.runOutsideAngular(function () {\n        if (klass[name]) {\n          return klass[name];\n        }\n\n        if (noopFunctions.includes(name)) {\n          return function () {};\n        }\n\n        var promise = observable.toPromise().then(function (mod) {\n          var ret = mod && mod[name];\n\n          if (typeof ret == 'function') {\n            return ret.bind(mod);\n          } else if (ret && ret.then) {\n            return ret.then(function (res) {\n              return zone.run(function () {\n                return res;\n              });\n            });\n          } else {\n            return zone.run(function () {\n              return ret;\n            });\n          }\n        });\n        return new Proxy(function () {\n          return undefined;\n        }, {\n          get: function get(_, name) {\n            return promise[name];\n          },\n          apply: function apply(self, _, args) {\n            return promise.then(function (it) {\n              return it && it.apply(void 0, _toConsumableArray(args));\n            });\n          }\n        });\n      });\n    }\n  });\n};","map":{"version":3,"sources":["../../../src/core/angularfire2.ts"],"names":[],"mappings":"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","sourcesContent":["import { InjectionToken, NgZone } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subscription, SchedulerLike, SchedulerAction, queueScheduler, Operator, Subscriber, TeardownLogic, asyncScheduler } from 'rxjs';\nimport { subscribeOn, observeOn, tap, share } from 'rxjs/operators';\n\n// Put in database.ts when we drop database-depreciated\n// SEMVER drop RealtimeDatabaseURL in favor of DATABASE_URL in next major\nexport const RealtimeDatabaseURL = new InjectionToken<string>('angularfire2.realtimeDatabaseURL');\nexport const DATABASE_URL = RealtimeDatabaseURL;\n\nfunction noop() { }\n\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nexport class ɵZoneScheduler implements SchedulerLike {\n  constructor(private zone: any, private delegate: any = queueScheduler) { }\n\n  now() {\n    return this.delegate.now();\n  }\n\n  schedule(work: (this: SchedulerAction<any>, state?: any) => void, delay?: number, state?: any): Subscription {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (this: SchedulerAction<any>, state: any) {\n      targetZone.runGuarded(() => {\n        work.apply(this, [state]);\n      });\n    }\n\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state)\n  }\n}\n\nexport class ɵBlockUntilFirstOperator<T> implements Operator<T, T> {\n  private task: MacroTask | null = null;\n\n  constructor(private zone: any) { }\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    const unscheduleTask = this.unscheduleTask.bind(this);\n    this.task = this.zone.run(() => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop));\n\n    return source.pipe(\n      tap(unscheduleTask, unscheduleTask, unscheduleTask)\n    ).subscribe(subscriber).add(unscheduleTask);\n  }\n\n  private unscheduleTask() {\n    if (this.task != null && this.task.state === 'scheduled') {\n      this.task.invoke();\n      this.task = null;\n    }\n  }\n}\n\nexport class ɵAngularFireSchedulers {\n  public readonly outsideAngular: ɵZoneScheduler;\n  public readonly insideAngular: ɵZoneScheduler;\n\n  constructor(public ngZone: NgZone) {\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(Zone.current, asyncScheduler));\n  }\n}\n\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n */\nexport function ɵkeepUnstableUntilFirstFactory(\n  schedulers: ɵAngularFireSchedulers,\n  platformId: Object\n) {\n  return function keepUnstableUntilFirst<T>(obs$: Observable<T>): Observable<T> {\n    if (isPlatformServer(platformId)) {\n      obs$ = obs$.lift(\n        new ɵBlockUntilFirstOperator(schedulers.ngZone)\n      );\n    }\n\n    return obs$.pipe(\n      // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular),\n      // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular)\n      // This isn't working correctly #2309, #2314, #2312\n      // share()\n    );\n  }\n}\n\n// SEMVER: drop v6, here for compatibility\nexport const runOutsideAngular = (zone: NgZone) => <T>(obs$: Observable<T>): Observable<T> => {\n  return new Observable<T>(subscriber => {\n    return zone.runOutsideAngular(() => {\n      runInZone(zone)(obs$).subscribe(subscriber);\n    });\n  });\n}\n\n// SEMVER: drop v6, here for compatibility\nexport const runInZone = (zone: NgZone) => <T>(obs$: Observable<T>): Observable<T> => {\n  return new Observable<T>(subscriber => {\n    return obs$.subscribe(\n      value => zone.run(() => subscriber.next(value)),\n      error => zone.run(() => subscriber.error(error)),\n      ()    => zone.run(() => subscriber.complete()),\n    );\n  });\n}\n\n// SEMVER: drop v6, here for compatibility\nexport class FirebaseZoneScheduler {\n  constructor(public zone: NgZone, private platformId: Object) {}\n  schedule(...args: any[]): Subscription {\n    return <Subscription>this.zone.runGuarded(function() { return queueScheduler.schedule.apply(queueScheduler, args)});\n  }\n  keepUnstableUntilFirst<T>(obs$: Observable<T>) {\n    if (isPlatformServer(this.platformId)) {\n      return new Observable<T>(subscriber => {\n        const noop = () => {};\n        const task = Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n        obs$.subscribe(\n          next => {\n            if (task.state === 'scheduled') { task.invoke() };\n            subscriber.next(next);\n          },\n          error => {\n            if (task.state === 'scheduled') { task.invoke() }\n            subscriber.error(error);\n          },\n          () => {\n            if (task.state === 'scheduled') { task.invoke() }\n            subscriber.complete();\n          }\n        );\n      });\n    } else {\n      return obs$;\n    }\n  }\n  runOutsideAngular<T>(obs$: Observable<T>): Observable<T> {\n    return new Observable<T>(subscriber => {\n      return this.zone.runOutsideAngular(() => {\n        return obs$.subscribe(\n          value => this.zone.run(() => subscriber.next(value)),\n          error => this.zone.run(() => subscriber.error(error)),\n          ()    => this.zone.run(() => subscriber.complete()),\n        );\n      });\n    });\n  }\n}\n\n//SEMVER: once we move to TypeScript 3.6, we can use these to build lazy interfaces\n/*\n  type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\n  type PromiseReturningFunctionPropertyNames<T> = { [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? K : never }[FunctionPropertyNames<T>];\n  type NonPromiseReturningFunctionPropertyNames<T> = { [K in FunctionPropertyNames<T>]: ReturnType<T[K]> extends Promise<any> ? never : K }[FunctionPropertyNames<T>];\n  type NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\n\n  export type PromiseProxy<T> = { [K in NonFunctionPropertyNames<T>]: Promise<T[K]> } &\n    { [K in NonPromiseReturningFunctionPropertyNames<T>]: (...args: Parameters<T[K]>) => Promise<ReturnType<T[K]>> } &\n    { [K in PromiseReturningFunctionPropertyNames<T>   ]: (...args: Parameters<T[K]>) => ReturnType<T[K]> };\n*/\n\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nexport const ɵlazySDKProxy = (klass: any, observable: Observable<any>, zone: NgZone) => {\n  return new Proxy(klass, {\n    get: (_, name:string) => zone.runOutsideAngular(() => {\n      if (klass[name]) { return klass[name] }\n      if (noopFunctions.includes(name)) { return () => {} }\n      let promise = observable.toPromise().then(mod => {\n        const ret = mod && mod[name];\n        // TODO move to proper type guards\n        if (typeof ret == 'function') {\n          return ret.bind(mod);\n        } else if (ret && ret.then) {\n          return ret.then((res:any) => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => undefined, {\n          get: (_, name) => promise[name],\n          // TODO handle callbacks as transparently as I can \n          apply: (self, _, args) => promise.then(it => it && it(...args))\n        }\n      )\n    })\n  })\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}