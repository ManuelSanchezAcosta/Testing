{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar typeFunc = require('type-func');\n\nvar animationFramePolyfill = require('animation-frame-polyfill');\n\nvar domSet = require('dom-set');\n\nvar domPlane = require('dom-plane');\n\nvar mousemoveDispatcher = _interopDefault(require('dom-mousemove-dispatcher'));\n\nfunction AutoScroller(elements, options) {\n  if (options === void 0) options = {};\n  var self = this;\n  var maxSpeed = 4,\n      scrolling = false;\n  this.margin = options.margin || -1; //this.scrolling = false;\n\n  this.scrollWhenOutside = options.scrollWhenOutside || false;\n  var point = {},\n      pointCB = domPlane.createPointCB(point),\n      dispatcher = mousemoveDispatcher(),\n      down = false;\n  window.addEventListener('mousemove', pointCB, false);\n  window.addEventListener('touchmove', pointCB, false);\n\n  if (!isNaN(options.maxSpeed)) {\n    maxSpeed = options.maxSpeed;\n  }\n\n  this.autoScroll = typeFunc.boolean(options.autoScroll);\n  this.syncMove = typeFunc.boolean(options.syncMove, false);\n\n  this.destroy = function (forceCleanAnimation) {\n    window.removeEventListener('mousemove', pointCB, false);\n    window.removeEventListener('touchmove', pointCB, false);\n    window.removeEventListener('mousedown', onDown, false);\n    window.removeEventListener('touchstart', onDown, false);\n    window.removeEventListener('mouseup', onUp, false);\n    window.removeEventListener('touchend', onUp, false);\n    window.removeEventListener('pointerup', onUp, false);\n    window.removeEventListener('mouseleave', onMouseOut, false);\n    window.removeEventListener('mousemove', onMove, false);\n    window.removeEventListener('touchmove', onMove, false);\n    window.removeEventListener('scroll', setScroll, true);\n    elements = [];\n\n    if (forceCleanAnimation) {\n      cleanAnimation();\n    }\n  };\n\n  this.add = function () {\n    var element = [],\n        len = arguments.length;\n\n    while (len--) {\n      element[len] = arguments[len];\n    }\n\n    domSet.addElements.apply(void 0, [elements].concat(element));\n    return this;\n  };\n\n  this.remove = function () {\n    var element = [],\n        len = arguments.length;\n\n    while (len--) {\n      element[len] = arguments[len];\n    }\n\n    return domSet.removeElements.apply(void 0, [elements].concat(element));\n  };\n\n  var hasWindow = null,\n      windowAnimationFrame;\n\n  if (Object.prototype.toString.call(elements) !== '[object Array]') {\n    elements = [elements];\n  }\n\n  (function (temp) {\n    elements = [];\n    temp.forEach(function (element) {\n      if (element === window) {\n        hasWindow = window;\n      } else {\n        self.add(element);\n      }\n    });\n  })(elements);\n\n  Object.defineProperties(this, {\n    down: {\n      get: function get() {\n        return down;\n      }\n    },\n    maxSpeed: {\n      get: function get() {\n        return maxSpeed;\n      }\n    },\n    point: {\n      get: function get() {\n        return point;\n      }\n    },\n    scrolling: {\n      get: function get() {\n        return scrolling;\n      }\n    }\n  });\n  var n = 0,\n      current = null,\n      animationFrame;\n  window.addEventListener('mousedown', onDown, false);\n  window.addEventListener('touchstart', onDown, false);\n  window.addEventListener('mouseup', onUp, false);\n  window.addEventListener('touchend', onUp, false);\n  /*\n  IE does not trigger mouseup event when scrolling.\n  It is a known issue that Microsoft won't fix.\n  https://connect.microsoft.com/IE/feedback/details/783058/scrollbar-trigger-mousedown-but-not-mouseup\n  IE supports pointer events instead\n  */\n\n  window.addEventListener('pointerup', onUp, false);\n  window.addEventListener('mousemove', onMove, false);\n  window.addEventListener('touchmove', onMove, false);\n  window.addEventListener('mouseleave', onMouseOut, false);\n  window.addEventListener('scroll', setScroll, true);\n\n  function setScroll(e) {\n    for (var i = 0; i < elements.length; i++) {\n      if (elements[i] === e.target) {\n        scrolling = true;\n        break;\n      }\n    }\n\n    if (scrolling) {\n      animationFramePolyfill.requestAnimationFrame(function () {\n        return scrolling = false;\n      });\n    }\n  }\n\n  function onDown() {\n    down = true;\n  }\n\n  function onUp() {\n    down = false;\n    cleanAnimation();\n  }\n\n  function cleanAnimation() {\n    animationFramePolyfill.cancelAnimationFrame(animationFrame);\n    animationFramePolyfill.cancelAnimationFrame(windowAnimationFrame);\n  }\n\n  function onMouseOut() {\n    down = false;\n  }\n\n  function getTarget(target) {\n    if (!target) {\n      return null;\n    }\n\n    if (current === target) {\n      return target;\n    }\n\n    if (domSet.hasElement(elements, target)) {\n      return target;\n    }\n\n    while (target = target.parentNode) {\n      if (domSet.hasElement(elements, target)) {\n        return target;\n      }\n    }\n\n    return null;\n  }\n\n  function getElementUnderPoint() {\n    var underPoint = null;\n\n    for (var i = 0; i < elements.length; i++) {\n      if (inside(point, elements[i])) {\n        underPoint = elements[i];\n      }\n    }\n\n    return underPoint;\n  }\n\n  function onMove(event) {\n    if (!self.autoScroll()) {\n      return;\n    }\n\n    if (event['dispatched']) {\n      return;\n    }\n\n    var target = event.target,\n        body = document.body;\n\n    if (current && !inside(point, current)) {\n      if (!self.scrollWhenOutside) {\n        current = null;\n      }\n    }\n\n    if (target && target.parentNode === body) {\n      //The special condition to improve speed.\n      target = getElementUnderPoint();\n    } else {\n      target = getTarget(target);\n\n      if (!target) {\n        target = getElementUnderPoint();\n      }\n    }\n\n    if (target && target !== current) {\n      current = target;\n    }\n\n    if (hasWindow) {\n      animationFramePolyfill.cancelAnimationFrame(windowAnimationFrame);\n      windowAnimationFrame = animationFramePolyfill.requestAnimationFrame(scrollWindow);\n    }\n\n    if (!current) {\n      return;\n    }\n\n    animationFramePolyfill.cancelAnimationFrame(animationFrame);\n    animationFrame = animationFramePolyfill.requestAnimationFrame(scrollTick);\n  }\n\n  function scrollWindow() {\n    autoScroll(hasWindow);\n    animationFramePolyfill.cancelAnimationFrame(windowAnimationFrame);\n    windowAnimationFrame = animationFramePolyfill.requestAnimationFrame(scrollWindow);\n  }\n\n  function scrollTick() {\n    if (!current) {\n      return;\n    }\n\n    autoScroll(current);\n    animationFramePolyfill.cancelAnimationFrame(animationFrame);\n    animationFrame = animationFramePolyfill.requestAnimationFrame(scrollTick);\n  }\n\n  function autoScroll(el) {\n    var rect = domPlane.getClientRect(el),\n        scrollx,\n        scrolly;\n\n    if (point.x < rect.left + self.margin) {\n      scrollx = Math.floor(Math.max(-1, (point.x - rect.left) / self.margin - 1) * self.maxSpeed);\n    } else if (point.x > rect.right - self.margin) {\n      scrollx = Math.ceil(Math.min(1, (point.x - rect.right) / self.margin + 1) * self.maxSpeed);\n    } else {\n      scrollx = 0;\n    }\n\n    if (point.y < rect.top + self.margin) {\n      scrolly = Math.floor(Math.max(-1, (point.y - rect.top) / self.margin - 1) * self.maxSpeed);\n    } else if (point.y > rect.bottom - self.margin) {\n      scrolly = Math.ceil(Math.min(1, (point.y - rect.bottom) / self.margin + 1) * self.maxSpeed);\n    } else {\n      scrolly = 0;\n    }\n\n    if (self.syncMove()) {\n      /*\n      Notes about mousemove event dispatch.\n      screen(X/Y) should need to be updated.\n      Some other properties might need to be set.\n      Keep the syncMove option default false until all inconsistencies are taken care of.\n      */\n      dispatcher.dispatch(el, {\n        pageX: point.pageX + scrollx,\n        pageY: point.pageY + scrolly,\n        clientX: point.x + scrollx,\n        clientY: point.y + scrolly\n      });\n    }\n\n    setTimeout(function () {\n      if (scrolly) {\n        scrollY(el, scrolly);\n      }\n\n      if (scrollx) {\n        scrollX(el, scrollx);\n      }\n    });\n  }\n\n  function scrollY(el, amount) {\n    if (el === window) {\n      window.scrollTo(el.pageXOffset, el.pageYOffset + amount);\n    } else {\n      el.scrollTop += amount;\n    }\n  }\n\n  function scrollX(el, amount) {\n    if (el === window) {\n      window.scrollTo(el.pageXOffset + amount, el.pageYOffset);\n    } else {\n      el.scrollLeft += amount;\n    }\n  }\n}\n\nfunction AutoScrollerFactory(element, options) {\n  return new AutoScroller(element, options);\n}\n\nfunction inside(point, el, rect) {\n  if (!rect) {\n    return domPlane.pointInside(point, el);\n  } else {\n    return point.y > rect.top && point.y < rect.bottom && point.x > rect.left && point.x < rect.right;\n  }\n}\n/*\ngit remote add origin https://github.com/hollowdoor/dom_autoscroller.git\ngit push -u origin master\n*/\n\n\nmodule.exports = AutoScrollerFactory;","map":null,"metadata":{},"sourceType":"script"}