{"ast":null,"code":"import _defineProperty from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/Manuel/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan, observeOn } from 'rxjs/operators';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nexport function validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n\n  return events;\n}\nexport var AngularFirestoreCollection = /*#__PURE__*/function () {\n  function AngularFirestoreCollection(ref, query, afs) {\n    _classCallCheck(this, AngularFirestoreCollection);\n\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n\n  _createClass(AngularFirestoreCollection, [{\n    key: \"stateChanges\",\n    value: function stateChanges(events) {\n      if (!events || events.length === 0) {\n        return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n      }\n\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst, map(function (actions) {\n        return actions.filter(function (change) {\n          return events.indexOf(change.type) > -1;\n        });\n      }), filter(function (changes) {\n        return changes.length > 0;\n      }));\n    }\n  }, {\n    key: \"auditTrail\",\n    value: function auditTrail(events) {\n      return this.stateChanges(events).pipe(scan(function (current, action) {\n        return [].concat(_toConsumableArray(current), _toConsumableArray(action));\n      }, []));\n    }\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges(events) {\n      var validatedEvents = validateEventsArray(events);\n      var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n      return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst, map(function (actions) {\n        return actions.payload.docs.map(function (a) {\n          if (options.idField) {\n            return Object.assign({}, a.data(), _defineProperty({}, options.idField, a.id));\n          } else {\n            return a.data();\n          }\n        });\n      }));\n    }\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      return this.ref.add(data);\n    }\n  }, {\n    key: \"doc\",\n    value: function doc(path) {\n      return new AngularFirestoreDocument(this.ref.doc(path), this.afs);\n    }\n  }]);\n\n  return AngularFirestoreCollection;\n}();","map":{"version":3,"sources":["../../../../../src/firestore/collection/collection.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, from } from 'rxjs';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { map, filter, scan, observeOn } from 'rxjs/operators';\nimport { firestore } from 'firebase/app';\n\nimport { DocumentChangeType, CollectionReference, Query, DocumentReference, DocumentData, DocumentChangeAction } from '../interfaces';\nimport { docChanges, sortedChanges } from './changes';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if(!events || events!.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T=DocumentData> {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param ref\n   */\n  constructor(\n    public readonly ref: CollectionReference,\n    private readonly query: Query,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param events\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if(!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        this.afs.keepUnstableUntilFirst\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n      this.afs.keepUnstableUntilFirst,\n      map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n      filter(changes =>  changes.length > 0)\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   * @param events\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   * @param events\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      this.afs.keepUnstableUntilFirst\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   * @param options\n   */\n  valueChanges(): Observable<T[]>\n  valueChanges({}): Observable<T[]>\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        this.afs.keepUnstableUntilFirst,\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as Object,\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data()\n          }\n        }))\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   * @param path\n   */\n  doc<T>(path?: string): AngularFirestoreDocument<T> {\n    return new AngularFirestoreDocument<T>(this.ref.doc(path), this.afs);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}