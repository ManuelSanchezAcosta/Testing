{"ast":null,"code":"import _classCallCheck from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as ɵngcc0 from '@angular/core';\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { InjectionToken, NgZone, PLATFORM_ID, Injectable, Inject, Optional } from '@angular/core';\nimport { of, from } from 'rxjs';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport { FIREBASE_OPTIONS, FIREBASE_APP_NAME, _firebaseAppFactory, ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from 'firebase/app';\nexport var EnablePersistenceToken = new InjectionToken('angularfire2.enableFirestorePersistence');\nexport var PersistenceSettingsToken = new InjectionToken('angularfire2.firestore.persistenceSettings');\nexport var FirestoreSettingsToken = new InjectionToken('angularfire2.firestore.settings');\nexport var ENABLE_PERSISTENCE = EnablePersistenceToken;\nexport var PERSISTENCE_SETTINGS = PersistenceSettingsToken;\nexport var SETTINGS = FirestoreSettingsToken;\nvar major = parseInt(firebase.SDK_VERSION.split('.')[0]);\nvar minor = parseInt(firebase.SDK_VERSION.split('.')[1]);\nexport var DefaultFirestoreSettings = major < 5 || major == 5 && minor < 8 ? {\n  timestampsInSnapshots: true\n} : {};\nexport function associateQuery(collectionRef) {\n  var queryFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (ref) {\n    return ref;\n  };\n  var query = queryFn(collectionRef);\n  var ref = collectionRef;\n  return {\n    query: query,\n    ref: ref\n  };\n}\n\nvar AngularFirestore = /*#__PURE__*/function () {\n  function AngularFirestore(options, nameOrConfig, shouldEnablePersistence, settings, platformId, zone, persistenceSettings) {\n    var _this = this;\n\n    _classCallCheck(this, AngularFirestore);\n\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);\n    this.firestore = zone.runOutsideAngular(function () {\n      var app = _firebaseAppFactory(options, zone, nameOrConfig);\n\n      var firestore = app.firestore();\n      firestore.settings(settings || DefaultFirestoreSettings);\n      return firestore;\n    });\n\n    if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n      var enablePersistence = function enablePersistence() {\n        try {\n          return from(_this.firestore.enablePersistence(persistenceSettings || undefined).then(function () {\n            return true;\n          }, function () {\n            return false;\n          }));\n        } catch (e) {\n          return of(false);\n        }\n      };\n\n      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n    } else {\n      this.persistenceEnabled$ = of(false);\n    }\n  }\n\n  _createClass(AngularFirestore, [{\n    key: \"collection\",\n    value: function collection(pathOrRef, queryFn) {\n      var collectionRef;\n\n      if (typeof pathOrRef === 'string') {\n        collectionRef = this.firestore.collection(pathOrRef);\n      } else {\n        collectionRef = pathOrRef;\n      }\n\n      var _associateQuery = associateQuery(collectionRef, queryFn),\n          ref = _associateQuery.ref,\n          query = _associateQuery.query;\n\n      return new AngularFirestoreCollection(ref, query, this);\n    }\n  }, {\n    key: \"collectionGroup\",\n    value: function collectionGroup(collectionId, queryGroupFn) {\n      if (major < 6) {\n        throw \"collection group queries require Firebase JS SDK >= 6.0\";\n      }\n\n      var queryFn = queryGroupFn || function (ref) {\n        return ref;\n      };\n\n      var firestore = this.firestore;\n      var collectionGroup = firestore.collectionGroup(collectionId);\n      return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n    }\n  }, {\n    key: \"doc\",\n    value: function doc(pathOrRef) {\n      var ref;\n\n      if (typeof pathOrRef === 'string') {\n        ref = this.firestore.doc(pathOrRef);\n      } else {\n        ref = pathOrRef;\n      }\n\n      return new AngularFirestoreDocument(ref, this);\n    }\n  }, {\n    key: \"createId\",\n    value: function createId() {\n      return this.firestore.collection('_').doc().id;\n    }\n  }]);\n\n  return AngularFirestore;\n}();\n\nAngularFirestore.ɵfac = function AngularFirestore_Factory(t) {\n  return new (t || AngularFirestore)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(ENABLE_PERSISTENCE, 8), ɵngcc0.ɵɵinject(SETTINGS, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PERSISTENCE_SETTINGS, 8));\n};\n\nAngularFirestore.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: AngularFirestore,\n  factory: function factory(t) {\n    return AngularFirestore.ɵfac(t);\n  }\n});\nAngularFirestore = __decorate([__param(0, Inject(FIREBASE_OPTIONS)), __param(1, Optional()), __param(1, Inject(FIREBASE_APP_NAME)), __param(2, Optional()), __param(2, Inject(ENABLE_PERSISTENCE)), __param(3, Optional()), __param(3, Inject(SETTINGS)), __param(4, Inject(PLATFORM_ID)), __param(6, Optional()), __param(6, Inject(PERSISTENCE_SETTINGS)), __metadata(\"design:paramtypes\", [Object, Object, Object, Object, Object, NgZone, Object])], AngularFirestore);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AngularFirestore, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [FIREBASE_OPTIONS]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FIREBASE_APP_NAME]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ENABLE_PERSISTENCE]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [SETTINGS]\n      }]\n    }, {\n      type: Object,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: Object,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [PERSISTENCE_SETTINGS]\n      }]\n    }];\n  }, null);\n})();\n\nexport { AngularFirestore };","map":{"version":3,"sources":["../../../../src/firestore/firestore.ts"],"names":[],"mappings":"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","sourcesContent":["import { InjectionToken, NgZone, PLATFORM_ID, Injectable, Inject, Optional } from '@angular/core';\n\nimport { Observable, of, from } from 'rxjs';\n\nimport { Settings, PersistenceSettings, CollectionReference, DocumentReference, QueryFn, Query, QueryGroupFn, AssociatedReference } from './interfaces';\nimport { AngularFirestoreDocument } from './document/document';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\n\nimport { FirebaseFirestore, FirebaseOptions, FirebaseAppConfig, FIREBASE_OPTIONS, FIREBASE_APP_NAME, _firebaseAppFactory, ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\n\n// Workaround for Nodejs build\n// @ts-ignore\nimport firebase from 'firebase/app';\n\n// SEMVER: have to import here while we target ng 6, as the version of typescript doesn't allow dynamic import of types\nimport { firestore } from 'firebase/app';\n\n// SEMVER drop EnablePersistenceToken, PersistenceSettingsToken, and FirestoreSettingsToken in favor of new export names\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const EnablePersistenceToken = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PersistenceSettingsToken = new InjectionToken<PersistenceSettings|undefined>('angularfire2.firestore.persistenceSettings');\nexport const FirestoreSettingsToken = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\nexport const ENABLE_PERSISTENCE = EnablePersistenceToken;\nexport const PERSISTENCE_SETTINGS = PersistenceSettingsToken\nexport const SETTINGS = FirestoreSettingsToken;\n\n// SEMVER kill this in the next major\n// timestampsInSnapshots was depreciated in 5.8.0\nconst major = parseInt(firebase.SDK_VERSION.split('.')[0]);\nconst minor = parseInt(firebase.SDK_VERSION.split('.')[1]);\nexport const DefaultFirestoreSettings = ((major < 5 || (major == 5 && minor < 8)) ? {timestampsInSnapshots: true} : {}) as Settings;\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery(collectionRef: CollectionReference, queryFn = ref => ref): AssociatedReference {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable()\nexport class AngularFirestore {\n  public readonly firestore: FirebaseFirestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   * @param app\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options:FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig:string|FirebaseAppConfig|null|undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean|null,\n    @Optional() @Inject(SETTINGS) settings: Settings|null,\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings|null,\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);\n\n    this.firestore = zone.runOutsideAngular(() => {\n      const app = _firebaseAppFactory(options, zone, nameOrConfig);\n      const firestore = app.firestore();\n      firestore.settings(settings || DefaultFirestoreSettings);\n      return firestore;\n    });\n\n    if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n      // We need to try/catch here because not all enablePersistence() failures are caught\n      // https://github.com/firebase/firebase-js-sdk/issues/608\n      const enablePersistence = () => {\n        try {\n          return from(this.firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n        } catch(e) {\n          return of(false);\n        }\n      };\n      this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);\n    } else {\n      this.persistenceEnabled$ = of(false);\n    }\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   * @param pathOrRef\n   * @param queryFn\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>\n  collection<T>(pathOrRef: string | CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef);\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<T>(ref, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   * @param collectionId\n   * @param queryGroupFn\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn): AngularFirestoreCollectionGroup<T> {\n    if (major < 6) { throw \"collection group queries require Firebase JS SDK >= 6.0\"}\n    const queryFn = queryGroupFn || (ref => ref);\n    const firestore: any = this.firestore; // SEMVER: ditch any once targeting >= 6.0\n    const collectionGroup: Query = firestore.collectionGroup(collectionId);\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   * @param pathOrRef\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>\n  doc<T>(pathOrRef: string | DocumentReference): AngularFirestoreDocument<T> {\n    let ref: DocumentReference;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef);\n    } else {\n      ref = pathOrRef;\n    }\n    return new AngularFirestoreDocument<T>(ref, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id\n  }\n}\n"]},"metadata":{},"sourceType":"module"}