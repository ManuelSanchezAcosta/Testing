{"ast":null,"code":"// Production steps of ECMA-262, Edition 6, 22.1.2.1\n// Reference: http://www.ecma-international.org/ecma-262/6.0/#sec-array.from\nmodule.exports = function () {\n  var isCallable = function isCallable(fn) {\n    return typeof fn === 'function';\n  };\n\n  var toInteger = function toInteger(value) {\n    var number = Number(value);\n\n    if (isNaN(number)) {\n      return 0;\n    }\n\n    if (number === 0 || !isFinite(number)) {\n      return number;\n    }\n\n    return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\n  };\n\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n\n  var toLength = function toLength(value) {\n    var len = toInteger(value);\n    return Math.min(Math.max(len, 0), maxSafeInteger);\n  };\n\n  var iteratorProp = function iteratorProp(value) {\n    if (value != null) {\n      if (['string', 'number', 'boolean', 'symbol'].indexOf(typeof value) > -1) {\n        return Symbol.iterator;\n      } else if (typeof Symbol !== 'undefined' && 'iterator' in Symbol && Symbol.iterator in value) {\n        return Symbol.iterator;\n      } // Support \"@@iterator\" placeholder, Gecko 27 to Gecko 35\n      else if ('@@iterator' in value) {\n          return '@@iterator';\n        }\n    }\n  };\n\n  var getMethod = function getMethod(O, P) {\n    // Assert: IsPropertyKey(P) is true.\n    if (O != null && P != null) {\n      // Let func be GetV(O, P).\n      var func = O[P]; // ReturnIfAbrupt(func).\n      // If func is either undefined or null, return undefined.\n\n      if (func == null) {\n        return void 0;\n      } // If IsCallable(func) is false, throw a TypeError exception.\n\n\n      if (!isCallable(func)) {\n        throw new TypeError(func + ' is not a function');\n      }\n\n      return func;\n    }\n  };\n\n  var iteratorStep = function iteratorStep(iterator) {\n    // Let result be IteratorNext(iterator).\n    // ReturnIfAbrupt(result).\n    var result = iterator.next(); // Let done be IteratorComplete(result).\n    // ReturnIfAbrupt(done).\n\n    var done = Boolean(result.done); // If done is true, return false.\n\n    if (done) {\n      return false;\n    } // Return result.\n\n\n    return result;\n  }; // The length property of the from method is 1.\n\n\n  return function from(items\n  /*, mapFn, thisArg */\n  ) {\n    'use strict'; // 1. Let C be the this value.\n\n    var C = this; // 2. If mapfn is undefined, let mapping be false.\n\n    var mapFn = arguments.length > 1 ? arguments[1] : void 0;\n    var T;\n\n    if (typeof mapFn !== 'undefined') {\n      // 3. else\n      //   a. If IsCallable(mapfn) is false, throw a TypeError exception.\n      if (!isCallable(mapFn)) {\n        throw new TypeError('Array.from: when provided, the second argument must be a function');\n      } //   b. If thisArg was supplied, let T be thisArg; else let T\n      //      be undefined.\n\n\n      if (arguments.length > 2) {\n        T = arguments[2];\n      } //   c. Let mapping be true (implied by mapFn)\n\n    }\n\n    var A, k; // 4. Let usingIterator be GetMethod(items, @@iterator).\n    // 5. ReturnIfAbrupt(usingIterator).\n\n    var usingIterator = getMethod(items, iteratorProp(items)); // 6. If usingIterator is not undefined, then\n\n    if (usingIterator !== void 0) {\n      // a. If IsConstructor(C) is true, then\n      //   i. Let A be the result of calling the [[Construct]]\n      //      internal method of C with an empty argument list.\n      // b. Else,\n      //   i. Let A be the result of the abstract operation ArrayCreate\n      //      with argument 0.\n      // c. ReturnIfAbrupt(A).\n      A = isCallable(C) ? Object(new C()) : []; // d. Let iterator be GetIterator(items, usingIterator).\n\n      var iterator = usingIterator.call(items); // e. ReturnIfAbrupt(iterator).\n\n      if (iterator == null) {\n        throw new TypeError('Array.from requires an array-like or iterable object');\n      } // f. Let k be 0.\n\n\n      k = 0; // g. Repeat\n\n      var next, nextValue;\n\n      while (true) {\n        // i. Let Pk be ToString(k).\n        // ii. Let next be IteratorStep(iterator).\n        // iii. ReturnIfAbrupt(next).\n        next = iteratorStep(iterator); // iv. If next is false, then\n\n        if (!next) {\n          // 1. Let setStatus be Set(A, \"length\", k, true).\n          // 2. ReturnIfAbrupt(setStatus).\n          A.length = k; // 3. Return A.\n\n          return A;\n        } // v. Let nextValue be IteratorValue(next).\n        // vi. ReturnIfAbrupt(nextValue)\n\n\n        nextValue = next.value; // vii. If mapping is true, then\n        //   1. Let mappedValue be Call(mapfn, T, «nextValue, k»).\n        //   2. If mappedValue is an abrupt completion, return\n        //      IteratorClose(iterator, mappedValue).\n        //   3. Let mappedValue be mappedValue.[[value]].\n        // viii. Else, let mappedValue be nextValue.\n        // ix.  Let defineStatus be the result of\n        //      CreateDataPropertyOrThrow(A, Pk, mappedValue).\n        // x. [TODO] If defineStatus is an abrupt completion, return\n        //    IteratorClose(iterator, defineStatus).\n\n        if (mapFn) {\n          A[k] = mapFn.call(T, nextValue, k);\n        } else {\n          A[k] = nextValue;\n        } // xi. Increase k by 1.\n\n\n        k++;\n      } // 7. Assert: items is not an Iterable so assume it is\n      //    an array-like object.\n\n    } else {\n      // 8. Let arrayLike be ToObject(items).\n      var arrayLike = Object(items); // 9. ReturnIfAbrupt(items).\n\n      if (items == null) {\n        throw new TypeError('Array.from requires an array-like object - not null or undefined');\n      } // 10. Let len be ToLength(Get(arrayLike, \"length\")).\n      // 11. ReturnIfAbrupt(len).\n\n\n      var len = toLength(arrayLike.length); // 12. If IsConstructor(C) is true, then\n      //     a. Let A be Construct(C, «len»).\n      // 13. Else\n      //     a. Let A be ArrayCreate(len).\n      // 14. ReturnIfAbrupt(A).\n\n      A = isCallable(C) ? Object(new C(len)) : new Array(len); // 15. Let k be 0.\n\n      k = 0; // 16. Repeat, while k < len… (also steps a - h)\n\n      var kValue;\n\n      while (k < len) {\n        kValue = arrayLike[k];\n\n        if (mapFn) {\n          A[k] = mapFn.call(T, kValue, k);\n        } else {\n          A[k] = kValue;\n        }\n\n        k++;\n      } // 17. Let setStatus be Set(A, \"length\", len, true).\n      // 18. ReturnIfAbrupt(setStatus).\n\n\n      A.length = len; // 19. Return A.\n    }\n\n    return A;\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}