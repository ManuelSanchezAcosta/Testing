{"ast":null,"code":"// previous version:\n// https://github.com/angular-ui/bootstrap/blob/07c31d0731f7cb068a1932b8e01d2312b796b4ec/src/position/position.js\nvar Positioning = /*@__PURE__*/function () {\n  function Positioning() {}\n\n  Positioning.prototype.getAllStyles = function (element) {\n    return window.getComputedStyle(element);\n  };\n\n  Positioning.prototype.getStyle = function (element, prop) {\n    return this.getAllStyles(element)[prop];\n  };\n\n  Positioning.prototype.isStaticPositioned = function (element) {\n    return (this.getStyle(element, 'position') || 'static') === 'static';\n  };\n\n  Positioning.prototype.offsetParent = function (element) {\n    var offsetParentEl = element.offsetParent || document.documentElement;\n\n    while (offsetParentEl && offsetParentEl !== document.documentElement && this.isStaticPositioned(offsetParentEl)) {\n      offsetParentEl = offsetParentEl.offsetParent;\n    }\n\n    return offsetParentEl || document.documentElement;\n  };\n\n  Positioning.prototype.position = function (element, round) {\n    if (round === void 0) {\n      round = true;\n    }\n\n    var elPosition;\n    var parentOffset = {\n      width: 0,\n      height: 0,\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    if (this.getStyle(element, 'position') === 'fixed') {\n      elPosition = element.getBoundingClientRect();\n    } else {\n      var offsetParentEl = this.offsetParent(element);\n      elPosition = this.offset(element, false);\n\n      if (offsetParentEl !== document.documentElement) {\n        parentOffset = this.offset(offsetParentEl, false);\n      }\n\n      parentOffset.top += offsetParentEl.clientTop;\n      parentOffset.left += offsetParentEl.clientLeft;\n    }\n\n    elPosition.top -= parentOffset.top;\n    elPosition.bottom -= parentOffset.top;\n    elPosition.left -= parentOffset.left;\n    elPosition.right -= parentOffset.left;\n\n    if (round) {\n      elPosition.top = Math.round(elPosition.top);\n      elPosition.bottom = Math.round(elPosition.bottom);\n      elPosition.left = Math.round(elPosition.left);\n      elPosition.right = Math.round(elPosition.right);\n    }\n\n    return elPosition;\n  };\n\n  Positioning.prototype.offset = function (element, round) {\n    if (round === void 0) {\n      round = true;\n    }\n\n    var elBcr = element.getBoundingClientRect();\n    var viewportOffset = {\n      top: window.pageYOffset - document.documentElement.clientTop,\n      left: window.pageXOffset - document.documentElement.clientLeft\n    };\n    var elOffset = {\n      height: elBcr.height || element.offsetHeight,\n      width: elBcr.width || element.offsetWidth,\n      top: elBcr.top + viewportOffset.top,\n      bottom: elBcr.bottom + viewportOffset.top,\n      left: elBcr.left + viewportOffset.left,\n      right: elBcr.right + viewportOffset.left\n    };\n\n    if (round) {\n      elOffset.height = Math.round(elOffset.height);\n      elOffset.width = Math.round(elOffset.width);\n      elOffset.top = Math.round(elOffset.top);\n      elOffset.bottom = Math.round(elOffset.bottom);\n      elOffset.left = Math.round(elOffset.left);\n      elOffset.right = Math.round(elOffset.right);\n    }\n\n    return elOffset;\n  };\n\n  Positioning.prototype.positionElements = function (hostElement, targetElement, placement, appendToBody) {\n    var hostElPosition = appendToBody ? this.offset(hostElement, false) : this.position(hostElement, false);\n    var targetElStyles = this.getAllStyles(targetElement);\n    var targetElBCR = targetElement.getBoundingClientRect();\n    var placementPrimary = placement.split('-')[0] || 'top';\n    var placementSecondary = placement.split('-')[1] || 'center';\n    var targetElPosition = {\n      'height': targetElBCR.height || targetElement.offsetHeight,\n      'width': targetElBCR.width || targetElement.offsetWidth,\n      'top': 0,\n      'bottom': targetElBCR.height || targetElement.offsetHeight,\n      'left': 0,\n      'right': targetElBCR.width || targetElement.offsetWidth\n    };\n\n    switch (placementPrimary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));\n        break;\n\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height;\n        break;\n\n      case 'left':\n        targetElPosition.left = hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));\n        break;\n\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width;\n        break;\n    }\n\n    switch (placementSecondary) {\n      case 'top':\n        targetElPosition.top = hostElPosition.top;\n        break;\n\n      case 'bottom':\n        targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;\n        break;\n\n      case 'left':\n        targetElPosition.left = hostElPosition.left;\n        break;\n\n      case 'right':\n        targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;\n        break;\n\n      case 'center':\n        if (placementPrimary === 'top' || placementPrimary === 'bottom') {\n          targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;\n        } else {\n          targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;\n        }\n\n        break;\n    }\n\n    targetElPosition.top = Math.round(targetElPosition.top);\n    targetElPosition.bottom = Math.round(targetElPosition.bottom);\n    targetElPosition.left = Math.round(targetElPosition.left);\n    targetElPosition.right = Math.round(targetElPosition.right);\n    return targetElPosition;\n  }; // get the availble placements of the target element in the viewport dependeing on the host element\n\n\n  Positioning.prototype.getAvailablePlacements = function (hostElement, targetElement) {\n    var availablePlacements = [];\n    var hostElemClientRect = hostElement.getBoundingClientRect();\n    var targetElemClientRect = targetElement.getBoundingClientRect();\n    var html = document.documentElement;\n    var windowHeight = window.innerHeight || html.clientHeight;\n    var windowWidth = window.innerWidth || html.clientWidth;\n    var hostElemClientRectHorCenter = hostElemClientRect.left + hostElemClientRect.width / 2;\n    var hostElemClientRectVerCenter = hostElemClientRect.top + hostElemClientRect.height / 2; // left: check if target width can be placed between host left and viewport start and also height of target is\n    // inside viewport\n\n    if (targetElemClientRect.width < hostElemClientRect.left) {\n      // check for left only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 && windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'left');\n      } // check for left-top and left-bottom\n\n\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'left', availablePlacements);\n    } // top: target height is less than host top\n\n\n    if (targetElemClientRect.height < hostElemClientRect.top) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 && windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'top');\n      }\n\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'top', availablePlacements);\n    } // right: check if target width can be placed between host right and viewport end and also height of target is\n    // inside viewport\n\n\n    if (windowWidth - hostElemClientRect.right > targetElemClientRect.width) {\n      // check for right only\n      if (hostElemClientRectVerCenter > targetElemClientRect.height / 2 && windowHeight - hostElemClientRectVerCenter > targetElemClientRect.height / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'right');\n      } // check for right-top and right-bottom\n\n\n      this.setSecondaryPlacementForLeftRight(hostElemClientRect, targetElemClientRect, 'right', availablePlacements);\n    } // bottom: check if there is enough space between host bottom and viewport end for target height\n\n\n    if (windowHeight - hostElemClientRect.bottom > targetElemClientRect.height) {\n      if (hostElemClientRectHorCenter > targetElemClientRect.width / 2 && windowWidth - hostElemClientRectHorCenter > targetElemClientRect.width / 2) {\n        availablePlacements.splice(availablePlacements.length, 1, 'bottom');\n      }\n\n      this.setSecondaryPlacementForTopBottom(hostElemClientRect, targetElemClientRect, 'bottom', availablePlacements);\n    }\n\n    return availablePlacements;\n  };\n  /**\r\n   * check if secondary placement for left and right are available i.e. left-top, left-bottom, right-top, right-bottom\r\n   * primaryplacement: left|right\r\n   * availablePlacementArr: array in which available placemets to be set\r\n   */\n\n\n  Positioning.prototype.setSecondaryPlacementForLeftRight = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n    var html = document.documentElement; // check for left-bottom\n\n    if (targetElemClientRect.height <= hostElemClientRect.bottom) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-bottom');\n    }\n\n    if ((window.innerHeight || html.clientHeight) - hostElemClientRect.top >= targetElemClientRect.height) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-top');\n    }\n  };\n  /**\r\n   * check if secondary placement for top and bottom are available i.e. top-left, top-right, bottom-left, bottom-right\r\n   * primaryplacement: top|bottom\r\n   * availablePlacementArr: array in which available placemets to be set\r\n   */\n\n\n  Positioning.prototype.setSecondaryPlacementForTopBottom = function (hostElemClientRect, targetElemClientRect, primaryPlacement, availablePlacementArr) {\n    var html = document.documentElement; // check for left-bottom\n\n    if ((window.innerWidth || html.clientWidth) - hostElemClientRect.left >= targetElemClientRect.width) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-left');\n    }\n\n    if (targetElemClientRect.width <= hostElemClientRect.right) {\n      availablePlacementArr.splice(availablePlacementArr.length, 1, primaryPlacement + '-right');\n    }\n  };\n\n  return Positioning;\n}();\n\nexport { Positioning };\nvar positionService = new Positioning();\n/*\r\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\r\n * Returns the applied placement.\r\n * In case of auto placement, placements are selected in order\r\n *   'top', 'bottom', 'left', 'right',\r\n *   'top-left', 'top-right',\r\n *   'bottom-left', 'bottom-right',\r\n *   'left-top', 'left-bottom',\r\n *   'right-top', 'right-bottom'.\r\n * */\n\nexport function positionElements(hostElement, targetElement, placement, appendToBody) {\n  var placementVals = Array.isArray(placement) ? placement : [placement]; // replace auto placement with other placements\n\n  var hasAuto = placementVals.findIndex(function (val) {\n    return val === 'auto';\n  });\n\n  if (hasAuto >= 0) {\n    ['top', 'bottom', 'left', 'right', 'top-left', 'top-right', 'bottom-left', 'bottom-right', 'left-top', 'left-bottom', 'right-top', 'right-bottom'].forEach(function (obj) {\n      if (placementVals.find(function (val) {\n        return val.search('^' + obj) !== -1;\n      }) == null) {\n        placementVals.splice(hasAuto++, 1, obj);\n      }\n    });\n  } // coordinates where to position\n\n\n  var topVal = 0,\n      leftVal = 0;\n  var appliedPlacement; // get available placements\n\n  var availablePlacements = positionService.getAvailablePlacements(hostElement, targetElement);\n\n  var _loop_1 = function _loop_1(item, index) {\n    // check if passed placement is present in the available placement or otherwise apply the last placement in the\n    // passed placement list\n    if (availablePlacements.find(function (val) {\n      return val === item;\n    }) != null || placementVals.length === index + 1) {\n      appliedPlacement = item;\n      var pos = positionService.positionElements(hostElement, targetElement, item, appendToBody);\n      topVal = pos.top;\n      leftVal = pos.left;\n      return \"break\";\n    }\n  }; // iterate over all the passed placements\n\n\n  for (var _i = 0, _a = toItemIndexes(placementVals); _i < _a.length; _i++) {\n    var _b = _a[_i],\n        item = _b.item,\n        index = _b.index;\n\n    var state_1 = _loop_1(item, index);\n\n    if (state_1 === \"break\") break;\n  }\n\n  targetElement.style.top = topVal + \"px\";\n  targetElement.style.left = leftVal + \"px\";\n  return appliedPlacement;\n} // function to get index and item of an array\n\nfunction toItemIndexes(a) {\n  return a.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  });\n}","map":null,"metadata":{},"sourceType":"module"}