{"ast":null,"code":"import _classCallCheck from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { WINDOW } from 'ngx-window-token';\nimport { Subject } from 'rxjs';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Inject, Injectable, Optional, Directive, EventEmitter, HostListener, Input, Output, TemplateRef, ViewContainerRef, NgModule, defineInjectable, inject } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The following code is heavily copied from https://github.com/zenorocha/clipboard.js\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar ClipboardService = /*@__PURE__*/function () {\n  var ClipboardService = /*#__PURE__*/function () {\n    /**\n     * @param {?} document\n     * @param {?} window\n     */\n    function ClipboardService(document, window) {\n      _classCallCheck(this, ClipboardService);\n\n      this.document = document;\n      this.window = window;\n      this.copySubject = new Subject();\n      this.copyResponse$ = this.copySubject.asObservable();\n      this.config = {};\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n\n\n    _createClass(ClipboardService, [{\n      key: \"configure\",\n      value: function configure(config) {\n        this.config = config;\n      }\n      /**\n       * @param {?} content\n       * @return {?}\n       */\n\n    }, {\n      key: \"copy\",\n      value: function copy(content) {\n        if (!this.isSupported || !content) {\n          return this.pushCopyResponse({\n            isSuccess: false,\n            content: content\n          });\n        }\n        /** @type {?} */\n\n\n        var copyResult = this.copyFromContent(content);\n\n        if (copyResult) {\n          return this.pushCopyResponse({\n            content: content,\n            isSuccess: copyResult\n          });\n        }\n\n        return this.pushCopyResponse({\n          isSuccess: false,\n          content: content\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isTargetValid\",\n\n      /**\n       * @param {?} element\n       * @return {?}\n       */\n      value: function isTargetValid(element) {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          if (element.hasAttribute('disabled')) {\n            throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n          }\n\n          return true;\n        }\n\n        throw new Error('Target should be input or textarea');\n      }\n      /**\n       * Attempts to copy from an input `targetElm`\n       * @param {?} targetElm\n       * @param {?=} isFocus\n       * @return {?}\n       */\n\n    }, {\n      key: \"copyFromInputElement\",\n      value: function copyFromInputElement(targetElm) {\n        var isFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        try {\n          this.selectTarget(targetElm);\n          /** @type {?} */\n\n          var re = this.copyText();\n          this.clearSelection(isFocus ? targetElm : undefined, this.window);\n          return re && this.isCopySuccessInIE11();\n        } catch (error) {\n          return false;\n        }\n      }\n      /**\n       * This is a hack for IE11 to return `true` even if copy fails.\n       * @return {?}\n       */\n\n    }, {\n      key: \"isCopySuccessInIE11\",\n      value: function isCopySuccessInIE11() {\n        /** @type {?} */\n        var clipboardData = this.window['clipboardData'];\n\n        if (clipboardData && clipboardData.getData) {\n          if (!clipboardData.getData('Text')) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      /**\n       * Creates a fake textarea element, sets its value from `text` property,\n       * and makes a selection on it.\n       * @param {?} content\n       * @param {?=} container\n       * @return {?}\n       */\n\n    }, {\n      key: \"copyFromContent\",\n      value: function copyFromContent(content) {\n        var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.document.body;\n\n        // check if the temp textarea still belongs to the current container.\n        // In case we have multiple places using ngx-clipboard, one is in a modal using container but the other one is not.\n        if (this.tempTextArea && !container.contains(this.tempTextArea)) {\n          this.destroy(this.tempTextArea.parentElement);\n        }\n\n        if (!this.tempTextArea) {\n          this.tempTextArea = this.createTempTextArea(this.document, this.window);\n\n          try {\n            container.appendChild(this.tempTextArea);\n          } catch (error) {\n            throw new Error('Container should be a Dom element');\n          }\n        }\n\n        this.tempTextArea.value = content;\n        /** @type {?} */\n\n        var toReturn = this.copyFromInputElement(this.tempTextArea, false);\n\n        if (this.config.cleanUpAfterCopy) {\n          this.destroy(this.tempTextArea.parentElement);\n        }\n\n        return toReturn;\n      }\n      /**\n       * Remove temporary textarea if any exists.\n       * @param {?=} container\n       * @return {?}\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.document.body;\n\n        if (this.tempTextArea) {\n          container.removeChild(this.tempTextArea); // removeChild doesn't remove the reference from memory\n\n          this.tempTextArea = undefined;\n        }\n      }\n      /**\n       * Select the target html input element.\n       * @private\n       * @param {?} inputElement\n       * @return {?}\n       */\n\n    }, {\n      key: \"selectTarget\",\n      value: function selectTarget(inputElement) {\n        inputElement.select();\n        inputElement.setSelectionRange(0, inputElement.value.length);\n        return inputElement.value.length;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"copyText\",\n      value: function copyText() {\n        return this.document.execCommand('copy');\n      }\n      /**\n       * Moves focus away from `target` and back to the trigger, removes current selection.\n       * @private\n       * @param {?} inputElement\n       * @param {?} window\n       * @return {?}\n       */\n\n    }, {\n      key: \"clearSelection\",\n      value: function clearSelection(inputElement, window) {\n        inputElement && inputElement.focus();\n        window.getSelection().removeAllRanges();\n      }\n      /**\n       * Creates a fake textarea for copy command.\n       * @private\n       * @param {?} doc\n       * @param {?} window\n       * @return {?}\n       */\n\n    }, {\n      key: \"createTempTextArea\",\n      value: function createTempTextArea(doc, window) {\n        /** @type {?} */\n        var isRTL = doc.documentElement.getAttribute('dir') === 'rtl';\n        /** @type {?} */\n\n        var ta;\n        ta = doc.createElement('textarea'); // Prevent zooming on iOS\n\n        ta.style.fontSize = '12pt'; // Reset box model\n\n        ta.style.border = '0';\n        ta.style.padding = '0';\n        ta.style.margin = '0'; // Move element out of screen horizontally\n\n        ta.style.position = 'absolute';\n        ta.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n        /** @type {?} */\n\n        var yPosition = window.pageYOffset || doc.documentElement.scrollTop;\n        ta.style.top = yPosition + 'px';\n        ta.setAttribute('readonly', '');\n        return ta;\n      }\n      /**\n       * Pushes copy operation response to copySubject, to provide global access\n       * to the response.\n       * @param {?} response\n       * @return {?}\n       */\n\n    }, {\n      key: \"pushCopyResponse\",\n      value: function pushCopyResponse(response) {\n        this.copySubject.next(response);\n      }\n      /**\n       * @deprecated use pushCopyResponse instead.\n       * @param {?} response\n       * @return {?}\n       */\n\n    }, {\n      key: \"pushCopyReponse\",\n      value: function pushCopyReponse(response) {\n        this.pushCopyResponse(response);\n      }\n    }, {\n      key: \"isSupported\",\n      get: function get() {\n        return !!this.document.queryCommandSupported && !!this.document.queryCommandSupported('copy') && !!this.window;\n      }\n    }]);\n\n    return ClipboardService;\n  }();\n\n  ClipboardService.ɵfac = function ClipboardService_Factory(t) {\n    return new (t || ClipboardService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(WINDOW, 8));\n  };\n\n  ClipboardService.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: ClipboardService,\n    factory: ClipboardService.ɵfac,\n    providedIn: 'root'\n  });\n  /** @nocollapse */\n\n  ClipboardService.ngInjectableDef = defineInjectable({\n    factory: function ClipboardService_Factory() {\n      return new ClipboardService(inject(DOCUMENT), inject(WINDOW, 8));\n    },\n    token: ClipboardService,\n    providedIn: \"root\"\n  });\n  return ClipboardService;\n}();\n\nvar ClipboardDirective = /*@__PURE__*/function () {\n  var ClipboardDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} clipboardSrv\n     */\n    function ClipboardDirective(clipboardSrv) {\n      _classCallCheck(this, ClipboardDirective);\n\n      this.clipboardSrv = clipboardSrv;\n      this.cbOnSuccess = new EventEmitter();\n      this.cbOnError = new EventEmitter();\n    } // tslint:disable-next-line:no-empty\n\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(ClipboardDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {}\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.clipboardSrv.destroy(this.container);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(event) {\n        if (!this.clipboardSrv.isSupported) {\n          this.handleResult(false, undefined, event);\n        } else if (this.targetElm && this.clipboardSrv.isTargetValid(this.targetElm)) {\n          this.handleResult(this.clipboardSrv.copyFromInputElement(this.targetElm), this.targetElm.value, event);\n        } else if (this.cbContent) {\n          this.handleResult(this.clipboardSrv.copyFromContent(this.cbContent, this.container), this.cbContent, event);\n        }\n      }\n      /**\n       * Fires an event based on the copy operation result.\n       * @private\n       * @param {?} succeeded\n       * @param {?} copiedContent\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"handleResult\",\n      value: function handleResult(succeeded, copiedContent, event) {\n        /** @type {?} */\n        var response = {\n          isSuccess: succeeded,\n          event: event\n        };\n\n        if (succeeded) {\n          response = Object.assign(response, {\n            content: copiedContent,\n            successMessage: this.cbSuccessMsg\n          });\n          this.cbOnSuccess.emit(response);\n        } else {\n          this.cbOnError.emit(response);\n        }\n\n        this.clipboardSrv.pushCopyResponse(response);\n      }\n    }]);\n\n    return ClipboardDirective;\n  }();\n\n  ClipboardDirective.ɵfac = function ClipboardDirective_Factory(t) {\n    return new (t || ClipboardDirective)(ɵngcc0.ɵɵdirectiveInject(ClipboardService));\n  };\n\n  ClipboardDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: ClipboardDirective,\n    selectors: [[\"\", \"ngxClipboard\", \"\"]],\n    hostBindings: function ClipboardDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function ClipboardDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event.target);\n        });\n      }\n    },\n    inputs: {\n      targetElm: [\"ngxClipboard\", \"targetElm\"],\n      container: \"container\",\n      cbContent: \"cbContent\",\n      cbSuccessMsg: \"cbSuccessMsg\"\n    },\n    outputs: {\n      cbOnSuccess: \"cbOnSuccess\",\n      cbOnError: \"cbOnError\"\n    }\n  });\n  return ClipboardDirective;\n}();\n\nvar ClipboardIfSupportedDirective = /*@__PURE__*/function () {\n  var ClipboardIfSupportedDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} _clipboardService\n     * @param {?} _viewContainerRef\n     * @param {?} _templateRef\n     */\n    function ClipboardIfSupportedDirective(_clipboardService, _viewContainerRef, _templateRef) {\n      _classCallCheck(this, ClipboardIfSupportedDirective);\n\n      this._clipboardService = _clipboardService;\n      this._viewContainerRef = _viewContainerRef;\n      this._templateRef = _templateRef;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(ClipboardIfSupportedDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (this._clipboardService.isSupported) {\n          this._viewContainerRef.createEmbeddedView(this._templateRef);\n        }\n      }\n    }]);\n\n    return ClipboardIfSupportedDirective;\n  }();\n\n  ClipboardIfSupportedDirective.ɵfac = function ClipboardIfSupportedDirective_Factory(t) {\n    return new (t || ClipboardIfSupportedDirective)(ɵngcc0.ɵɵdirectiveInject(ClipboardService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  ClipboardIfSupportedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: ClipboardIfSupportedDirective,\n    selectors: [[\"\", \"ngxClipboardIfSupported\", \"\"]]\n  });\n  return ClipboardIfSupportedDirective;\n}();\n\nvar ClipboardModule = /*@__PURE__*/function () {\n  var ClipboardModule = function ClipboardModule() {\n    _classCallCheck(this, ClipboardModule);\n  };\n\n  ClipboardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: ClipboardModule\n  });\n  ClipboardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function ClipboardModule_Factory(t) {\n      return new (t || ClipboardModule)();\n    },\n    imports: [[CommonModule]]\n  });\n  return ClipboardModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClipboardModule, {\n    declarations: function declarations() {\n      return [ClipboardDirective, ClipboardIfSupportedDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [ClipboardDirective, ClipboardIfSupportedDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { ClipboardService, ClipboardDirective, ClipboardModule, ClipboardIfSupportedDirective };","map":null,"metadata":{},"sourceType":"module"}