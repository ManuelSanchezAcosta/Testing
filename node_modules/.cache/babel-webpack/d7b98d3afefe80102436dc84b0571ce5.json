{"ast":null,"code":"import _slicedToArray from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Subject, Observable, merge, ReplaySubject, combineLatest, animationFrameScheduler } from 'rxjs';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from 'dom-autoscroller';\nimport { Injectable, Directive, ElementRef, Input, NgZone, Renderer2, Output, EventEmitter, Inject, ViewContainerRef, Optional, NgModule, defineInjectable } from '@angular/core';\nimport { map, mergeMap, takeUntil, take, takeLast, pairwise, share, filter, count, startWith, auditTime, distinctUntilChanged } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar DraggableHelper = function DraggableHelper() {\n  _classCallCheck(this, DraggableHelper);\n\n  this.currentDrag = new Subject();\n};\n\nDraggableHelper.ɵfac = function DraggableHelper_Factory(t) {\n  return new (t || DraggableHelper)();\n};\n\nDraggableHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: DraggableHelper,\n  factory: DraggableHelper.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\n\nDraggableHelper.ngInjectableDef = defineInjectable({\n  factory: function DraggableHelper_Factory() {\n    return new DraggableHelper();\n  },\n  token: DraggableHelper,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableHelper, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n * <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n * <div mwlDraggable>Drag me!</div>\n * </div>\n * ```\n */\n\n\nvar DraggableScrollContainerDirective = /*#__PURE__*/function () {\n  /**\n   * @hidden\n   * @param {?} elementRef\n   * @param {?} renderer\n   * @param {?} zone\n   */\n  function DraggableScrollContainerDirective(elementRef, renderer, zone) {\n    _classCallCheck(this, DraggableScrollContainerDirective);\n\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    this.zone = zone;\n    /**\n     * Trigger the DragStart after a long touch in scrollable container when true\n     */\n\n    this.activeLongPressDrag = false;\n    /**\n     * Configuration of a long touch\n     * Duration in ms of a long touch before activating DragStart\n     * Delta of the\n     */\n\n    this.longPressConfig = {\n      duration: 300,\n      delta: 30\n    };\n    this.cancelledScroll = false;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DraggableScrollContainerDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this = this;\n\n      this.zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this.renderer.listen(_this.elementRef.nativeElement, 'touchmove',\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          if (_this.cancelledScroll && event.cancelable) {\n            event.preventDefault();\n          }\n        });\n      });\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n\n  }, {\n    key: \"disableScroll\",\n    value: function disableScroll() {\n      this.cancelledScroll = true;\n      this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'hidden');\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n\n  }, {\n    key: \"enableScroll\",\n    value: function enableScroll() {\n      this.cancelledScroll = false;\n      this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'auto');\n    }\n    /**\n     * @hidden\n     * @return {?}\n     */\n\n  }, {\n    key: \"hasScrollbar\",\n    value: function hasScrollbar() {\n      /** @type {?} */\n      var containerHasHorizontalScroll = this.elementRef.nativeElement.scrollWidth - this.elementRef.nativeElement.clientWidth > 0;\n      /** @type {?} */\n\n      var containerHasVerticalScroll = this.elementRef.nativeElement.scrollHeight - this.elementRef.nativeElement.clientHeight > 0;\n      return containerHasHorizontalScroll || containerHasVerticalScroll;\n    }\n  }]);\n\n  return DraggableScrollContainerDirective;\n}();\n\nDraggableScrollContainerDirective.ɵfac = function DraggableScrollContainerDirective_Factory(t) {\n  return new (t || DraggableScrollContainerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nDraggableScrollContainerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableScrollContainerDirective,\n  selectors: [[\"\", \"mwlDraggableScrollContainer\", \"\"]],\n  inputs: {\n    activeLongPressDrag: \"activeLongPressDrag\",\n    longPressConfig: \"longPressConfig\"\n  }\n});\n/** @nocollapse */\n\nDraggableScrollContainerDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: NgZone\n  }];\n};\n\nDraggableScrollContainerDirective.propDecorators = {\n  activeLongPressDrag: [{\n    type: Input\n  }],\n  longPressConfig: [{\n    type: Input\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableScrollContainerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggableScrollContainer]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    activeLongPressDrag: [{\n      type: Input\n    }],\n    longPressConfig: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DraggableDirective = /*#__PURE__*/function () {\n  /**\n   * @hidden\n   * @param {?} element\n   * @param {?} renderer\n   * @param {?} draggableHelper\n   * @param {?} zone\n   * @param {?} vcr\n   * @param {?} scrollContainer\n   * @param {?} document\n   */\n  function DraggableDirective(element, renderer, draggableHelper, zone, vcr, scrollContainer, document) {\n    _classCallCheck(this, DraggableDirective);\n\n    this.element = element;\n    this.renderer = renderer;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.vcr = vcr;\n    this.scrollContainer = scrollContainer;\n    this.document = document;\n    /**\n     * The axis along which the element is draggable\n     */\n\n    this.dragAxis = {\n      x: true,\n      y: true\n    };\n    /**\n     * Snap all drags to an x / y grid\n     */\n\n    this.dragSnapGrid = {};\n    /**\n     * Show a ghost element that shows the drag when dragging\n     */\n\n    this.ghostDragEnabled = true;\n    /**\n     * Show the original element when ghostDragEnabled is true\n     */\n\n    this.showOriginalElementWhileDragging = false;\n    /**\n     * The cursor to use when hovering over a draggable element\n     */\n\n    this.dragCursor = '';\n    /**\n     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n     */\n\n    this.dragPointerDown = new EventEmitter();\n    /**\n     * Called when the element has started to be dragged.\n     * Only called after at least one mouse or touch move event.\n     * If you call $event.cancelDrag$.emit() it will cancel the current drag\n     */\n\n    this.dragStart = new EventEmitter();\n    /**\n     * Called after the ghost element has been created\n     */\n\n    this.ghostElementCreated = new EventEmitter();\n    /**\n     * Called when the element is being dragged\n     */\n\n    this.dragging = new EventEmitter();\n    /**\n     * Called after the element is dragged\n     */\n\n    this.dragEnd = new EventEmitter();\n    /**\n     * @hidden\n     */\n\n    this.pointerDown$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerMove$ = new Subject();\n    /**\n     * @hidden\n     */\n\n    this.pointerUp$ = new Subject();\n    this.eventListenerSubscriptions = {};\n    this.destroy$ = new Subject();\n    this.timeLongPress = {\n      timerBegin: 0,\n      timerEnd: 0\n    };\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DraggableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this2 = this;\n\n      this.checkEventListeners();\n      /** @type {?} */\n\n      var pointerDragged$ = this.pointerDown$.pipe(filter(\n      /**\n      * @return {?}\n      */\n      function () {\n        return _this2.canDrag();\n      }), mergeMap(\n      /**\n      * @param {?} pointerDownEvent\n      * @return {?}\n      */\n      function (pointerDownEvent) {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !_this2.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        }\n        /** @type {?} */\n\n\n        var startScrollPosition = _this2.getScrollPosition();\n        /** @type {?} */\n\n\n        var scrollContainerScroll$ = new Observable(\n        /**\n        * @param {?} observer\n        * @return {?}\n        */\n        function (observer) {\n          /** @type {?} */\n          var scrollContainer = _this2.scrollContainer ? _this2.scrollContainer.elementRef.nativeElement : 'window';\n          return _this2.renderer.listen(scrollContainer, 'scroll',\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          function (e) {\n            return observer.next(e);\n          });\n        }).pipe(startWith(startScrollPosition), map(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this2.getScrollPosition();\n        }));\n        /** @type {?} */\n\n        var currentDrag$ = new Subject();\n        /** @type {?} */\n\n        var cancelDrag$ = new ReplaySubject();\n\n        _this2.zone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2.dragPointerDown.next({\n            x: 0,\n            y: 0\n          });\n        });\n        /** @type {?} */\n\n\n        var dragComplete$ = merge(_this2.pointerUp$, _this2.pointerDown$, cancelDrag$, _this2.destroy$).pipe(share());\n        /** @type {?} */\n\n        var pointerMove = combineLatest([_this2.pointerMove$, scrollContainerScroll$]).pipe(map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              pointerMoveEvent = _ref2[0],\n              scroll = _ref2[1];\n\n          return {\n            currentDrag$: currentDrag$,\n            transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n            transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n            clientX: pointerMoveEvent.clientX,\n            clientY: pointerMoveEvent.clientY,\n            scrollLeft: scroll.left,\n            scrollTop: scroll.top\n          };\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        function (moveData) {\n          if (_this2.dragSnapGrid.x) {\n            moveData.transformX = Math.round(moveData.transformX / _this2.dragSnapGrid.x) * _this2.dragSnapGrid.x;\n          }\n\n          if (_this2.dragSnapGrid.y) {\n            moveData.transformY = Math.round(moveData.transformY / _this2.dragSnapGrid.y) * _this2.dragSnapGrid.y;\n          }\n\n          return moveData;\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        function (moveData) {\n          if (!_this2.dragAxis.x) {\n            moveData.transformX = 0;\n          }\n\n          if (!_this2.dragAxis.y) {\n            moveData.transformY = 0;\n          }\n\n          return moveData;\n        }), map(\n        /**\n        * @param {?} moveData\n        * @return {?}\n        */\n        function (moveData) {\n          /** @type {?} */\n          var scrollX = moveData.scrollLeft - startScrollPosition.left;\n          /** @type {?} */\n\n          var scrollY = moveData.scrollTop - startScrollPosition.top;\n          return Object.assign({}, moveData, {\n            x: moveData.transformX + scrollX,\n            y: moveData.transformY + scrollY\n          });\n        }), filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref3) {\n          var x = _ref3.x,\n              y = _ref3.y,\n              transformX = _ref3.transformX,\n              transformY = _ref3.transformY;\n          return !_this2.validateDrag || _this2.validateDrag({\n            x: x,\n            y: y,\n            transform: {\n              x: transformX,\n              y: transformY\n            }\n          });\n        }), takeUntil(dragComplete$), share());\n        /** @type {?} */\n\n        var dragStarted$ = pointerMove.pipe(take(1), share());\n        /** @type {?} */\n\n        var dragEnded$ = pointerMove.pipe(takeLast(1), share());\n        dragStarted$.subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref4) {\n          var clientX = _ref4.clientX,\n              clientY = _ref4.clientY,\n              x = _ref4.x,\n              y = _ref4.y;\n\n          _this2.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.dragStart.next({\n              cancelDrag$: cancelDrag$\n            });\n          });\n\n          _this2.scroller = autoScroll([_this2.scrollContainer ? _this2.scrollContainer.elementRef.nativeElement : _this2.document.defaultView], {\n            margin: 20,\n\n            /**\n             * @return {?}\n             */\n            autoScroll: function autoScroll() {\n              return true;\n            }\n          });\n\n          _this2.renderer.addClass(_this2.element.nativeElement, _this2.dragActiveClass);\n\n          if (_this2.ghostDragEnabled) {\n            /** @type {?} */\n            var rect = _this2.element.nativeElement.getBoundingClientRect();\n            /** @type {?} */\n\n\n            var clone =\n            /** @type {?} */\n            _this2.element.nativeElement.cloneNode(true);\n\n            if (!_this2.showOriginalElementWhileDragging) {\n              _this2.renderer.setStyle(_this2.element.nativeElement, 'visibility', 'hidden');\n            }\n\n            if (_this2.ghostElementAppendTo) {\n              _this2.ghostElementAppendTo.appendChild(clone);\n            } else {\n              /** @type {?} */\n              _this2.element.nativeElement.parentNode.insertBefore(clone, _this2.element.nativeElement.nextSibling);\n            }\n\n            _this2.ghostElement = clone;\n            document.body.style.cursor = _this2.dragCursor;\n\n            _this2.setElementStyles(clone, {\n              position: 'fixed',\n              top: \"\".concat(rect.top, \"px\"),\n              left: \"\".concat(rect.left, \"px\"),\n              width: \"\".concat(rect.width, \"px\"),\n              height: \"\".concat(rect.height, \"px\"),\n              cursor: _this2.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none'\n            });\n\n            if (_this2.ghostElementTemplate) {\n              /** @type {?} */\n              var viewRef = _this2.vcr.createEmbeddedView(_this2.ghostElementTemplate);\n\n              clone.innerHTML = '';\n              viewRef.rootNodes.filter(\n              /**\n              * @param {?} node\n              * @return {?}\n              */\n              function (node) {\n                return node instanceof Node;\n              }).forEach(\n              /**\n              * @param {?} node\n              * @return {?}\n              */\n              function (node) {\n                clone.appendChild(node);\n              });\n              dragEnded$.subscribe(\n              /**\n              * @return {?}\n              */\n              function () {\n                _this2.vcr.remove(_this2.vcr.indexOf(viewRef));\n              });\n            }\n\n            _this2.zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              _this2.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n\n            dragEnded$.subscribe(\n            /**\n            * @return {?}\n            */\n            function () {\n              /** @type {?} */\n              clone.parentElement.removeChild(clone);\n              _this2.ghostElement = null;\n\n              _this2.renderer.setStyle(_this2.element.nativeElement, 'visibility', '');\n            });\n          }\n\n          _this2.draggableHelper.currentDrag.next(currentDrag$);\n        });\n        dragEnded$.pipe(mergeMap(\n        /**\n        * @param {?} dragEndData\n        * @return {?}\n        */\n        function (dragEndData) {\n          /** @type {?} */\n          var dragEndData$ = cancelDrag$.pipe(count(), take(1), map(\n          /**\n          * @param {?} calledCount\n          * @return {?}\n          */\n          function (calledCount) {\n            return Object.assign({}, dragEndData, {\n              dragCancelled: calledCount > 0\n            });\n          }));\n          cancelDrag$.complete();\n          return dragEndData$;\n        })).subscribe(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref5) {\n          var x = _ref5.x,\n              y = _ref5.y,\n              dragCancelled = _ref5.dragCancelled;\n\n          _this2.scroller.destroy();\n\n          _this2.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this2.dragEnd.next({\n              x: x,\n              y: y,\n              dragCancelled: dragCancelled\n            });\n          });\n\n          _this2.renderer.removeClass(_this2.element.nativeElement, _this2.dragActiveClass);\n\n          currentDrag$.complete();\n        });\n        /** @type {?} */\n\n        var selectionStart$ = new Observable(\n        /**\n        * @param {?} observer\n        * @return {?}\n        */\n        function (observer) {\n          return _this2.renderer.listen('document', 'selectstart',\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          function (e) {\n            return observer.next(e);\n          });\n        }); // hack to prevent text getting selected in safari while dragging\n\n        selectionStart$.pipe(takeUntil(merge(dragComplete$, dragEnded$))).subscribe(\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        function (event) {\n          event.preventDefault();\n        });\n        return pointerMove;\n      }), share());\n      merge(pointerDragged$.pipe(take(1), map(\n      /**\n      * @param {?} value\n      * @return {?}\n      */\n      function (value) {\n        return [, value];\n      })), pointerDragged$.pipe(pairwise())).pipe(filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            previous = _ref7[0],\n            next = _ref7[1];\n\n        if (!previous) {\n          return true;\n        }\n\n        return previous.x !== next.x || previous.y !== next.y;\n      }), map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref8) {\n        var _ref9 = _slicedToArray(_ref8, 2),\n            previous = _ref9[0],\n            next = _ref9[1];\n\n        return next;\n      }), auditTime(0, animationFrameScheduler)).subscribe(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref10) {\n        var x = _ref10.x,\n            y = _ref10.y,\n            currentDrag$ = _ref10.currentDrag$,\n            clientX = _ref10.clientX,\n            clientY = _ref10.clientY,\n            transformX = _ref10.transformX,\n            transformY = _ref10.transformY;\n\n        _this2.zone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2.dragging.next({\n            x: x,\n            y: y\n          });\n        });\n\n        if (_this2.ghostElement) {\n          /** @type {?} */\n          var transform = \"translate3d(\".concat(transformX, \"px, \").concat(transformY, \"px, 0px)\");\n\n          _this2.setElementStyles(_this2.ghostElement, {\n            transform: transform,\n            '-webkit-transform': transform,\n            '-ms-transform': transform,\n            '-moz-transform': transform,\n            '-o-transform': transform\n          });\n        }\n\n        currentDrag$.next({\n          clientX: clientX,\n          clientY: clientY,\n          dropData: _this2.dropData\n        });\n      });\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      if (changes.dragAxis) {\n        this.checkEventListeners();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.unsubscribeEventListeners();\n      this.pointerDown$.complete();\n      this.pointerMove$.complete();\n      this.pointerUp$.complete();\n      this.destroy$.next();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"checkEventListeners\",\n    value: function checkEventListeners() {\n      var _this3 = this;\n\n      /** @type {?} */\n      var canDrag = this.canDrag();\n      /** @type {?} */\n\n      var hasEventListeners = Object.keys(this.eventListenerSubscriptions).length > 0;\n\n      if (canDrag && !hasEventListeners) {\n        this.zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this3.eventListenerSubscriptions.mousedown = _this3.renderer.listen(_this3.element.nativeElement, 'mousedown',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this3.onMouseDown(event);\n          });\n          _this3.eventListenerSubscriptions.mouseup = _this3.renderer.listen('document', 'mouseup',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this3.onMouseUp(event);\n          });\n          _this3.eventListenerSubscriptions.touchstart = _this3.renderer.listen(_this3.element.nativeElement, 'touchstart',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this3.onTouchStart(event);\n          });\n          _this3.eventListenerSubscriptions.touchend = _this3.renderer.listen('document', 'touchend',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this3.onTouchEnd(event);\n          });\n          _this3.eventListenerSubscriptions.touchcancel = _this3.renderer.listen('document', 'touchcancel',\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            _this3.onTouchEnd(event);\n          });\n          _this3.eventListenerSubscriptions.mouseenter = _this3.renderer.listen(_this3.element.nativeElement, 'mouseenter',\n          /**\n          * @return {?}\n          */\n          function () {\n            _this3.onMouseEnter();\n          });\n          _this3.eventListenerSubscriptions.mouseleave = _this3.renderer.listen(_this3.element.nativeElement, 'mouseleave',\n          /**\n          * @return {?}\n          */\n          function () {\n            _this3.onMouseLeave();\n          });\n        });\n      } else if (!canDrag && hasEventListeners) {\n        this.unsubscribeEventListeners();\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(event) {\n      var _this4 = this;\n\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove = this.renderer.listen('document', 'mousemove',\n        /**\n        * @param {?} mouseMoveEvent\n        * @return {?}\n        */\n        function (mouseMoveEvent) {\n          _this4.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        });\n      }\n\n      this.pointerDown$.next({\n        event: event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(event) {\n      if (this.eventListenerSubscriptions.mousemove) {\n        this.eventListenerSubscriptions.mousemove();\n        delete this.eventListenerSubscriptions.mousemove;\n      }\n\n      this.pointerUp$.next({\n        event: event,\n        clientX: event.clientX,\n        clientY: event.clientY\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(event) {\n      var _this5 = this;\n\n      if (!this.scrollContainer) {\n        try {\n          event.preventDefault();\n        } catch (e) {}\n      }\n      /** @type {?} */\n\n\n      var hasContainerScrollbar;\n      /** @type {?} */\n\n      var startScrollPosition;\n      /** @type {?} */\n\n      var isDragActivated;\n\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n        this.timeLongPress.timerBegin = Date.now();\n        isDragActivated = false;\n        hasContainerScrollbar = this.scrollContainer.hasScrollbar();\n        startScrollPosition = this.getScrollPosition();\n      }\n\n      if (!this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove = this.renderer.listen('document', 'touchmove',\n        /**\n        * @param {?} touchMoveEvent\n        * @return {?}\n        */\n        function (touchMoveEvent) {\n          if (_this5.scrollContainer && _this5.scrollContainer.activeLongPressDrag && !isDragActivated && hasContainerScrollbar) {\n            isDragActivated = _this5.shouldBeginDrag(event, touchMoveEvent, startScrollPosition);\n          }\n\n          if (!_this5.scrollContainer || !_this5.scrollContainer.activeLongPressDrag || !hasContainerScrollbar || isDragActivated) {\n            _this5.pointerMove$.next({\n              event: touchMoveEvent,\n              clientX: touchMoveEvent.targetTouches[0].clientX,\n              clientY: touchMoveEvent.targetTouches[0].clientY\n            });\n          }\n        });\n      }\n\n      this.pointerDown$.next({\n        event: event,\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY\n      });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(event) {\n      if (this.eventListenerSubscriptions.touchmove) {\n        this.eventListenerSubscriptions.touchmove();\n        delete this.eventListenerSubscriptions.touchmove;\n\n        if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n          this.scrollContainer.enableScroll();\n        }\n      }\n\n      this.pointerUp$.next({\n        event: event,\n        clientX: event.changedTouches[0].clientX,\n        clientY: event.changedTouches[0].clientY\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter() {\n      this.setCursor(this.dragCursor);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave() {\n      this.setCursor('');\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"canDrag\",\n    value: function canDrag() {\n      return this.dragAxis.x || this.dragAxis.y;\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(value) {\n      if (!this.eventListenerSubscriptions.mousemove) {\n        this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"unsubscribeEventListeners\",\n    value: function unsubscribeEventListeners() {\n      var _this6 = this;\n\n      Object.keys(this.eventListenerSubscriptions).forEach(\n      /**\n      * @param {?} type\n      * @return {?}\n      */\n      function (type) {\n        /** @type {?} */\n        _this6.eventListenerSubscriptions[type]();\n\n        delete\n        /** @type {?} */\n        _this6.eventListenerSubscriptions[type];\n      });\n    }\n    /**\n     * @private\n     * @param {?} element\n     * @param {?} styles\n     * @return {?}\n     */\n\n  }, {\n    key: \"setElementStyles\",\n    value: function setElementStyles(element, styles) {\n      var _this7 = this;\n\n      Object.keys(styles).forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      function (key) {\n        _this7.renderer.setStyle(element, key, styles[key]);\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getScrollPosition\",\n    value: function getScrollPosition() {\n      if (this.scrollContainer) {\n        return {\n          top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n          left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n        };\n      } else {\n        return {\n          top: window.pageYOffset || document.documentElement.scrollTop,\n          left: window.pageXOffset || document.documentElement.scrollLeft\n        };\n      }\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @param {?} touchMoveEvent\n     * @param {?} startScrollPosition\n     * @return {?}\n     */\n\n  }, {\n    key: \"shouldBeginDrag\",\n    value: function shouldBeginDrag(event, touchMoveEvent, startScrollPosition) {\n      /** @type {?} */\n      var moveScrollPosition = this.getScrollPosition();\n      /** @type {?} */\n\n      var deltaScroll = {\n        top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n        left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n      };\n      /** @type {?} */\n\n      var deltaX = Math.abs(touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX) - deltaScroll.left;\n      /** @type {?} */\n\n      var deltaY = Math.abs(touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY) - deltaScroll.top;\n      /** @type {?} */\n\n      var deltaTotal = deltaX + deltaY;\n\n      if (deltaTotal > this.scrollContainer.longPressConfig.delta || deltaScroll.top > 0 || deltaScroll.left > 0) {\n        this.timeLongPress.timerBegin = Date.now();\n      }\n\n      this.timeLongPress.timerEnd = Date.now();\n      /** @type {?} */\n\n      var duration = this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n\n      if (duration >= this.scrollContainer.longPressConfig.duration) {\n        this.scrollContainer.disableScroll();\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return DraggableDirective;\n}();\n\nDraggableDirective.ɵfac = function DraggableDirective_Factory(t) {\n  return new (t || DraggableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n};\n\nDraggableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DraggableDirective,\n  selectors: [[\"\", \"mwlDraggable\", \"\"]],\n  inputs: {\n    dragAxis: \"dragAxis\",\n    dragSnapGrid: \"dragSnapGrid\",\n    ghostDragEnabled: \"ghostDragEnabled\",\n    showOriginalElementWhileDragging: \"showOriginalElementWhileDragging\",\n    dragCursor: \"dragCursor\",\n    dropData: \"dropData\",\n    validateDrag: \"validateDrag\",\n    dragActiveClass: \"dragActiveClass\",\n    ghostElementAppendTo: \"ghostElementAppendTo\",\n    ghostElementTemplate: \"ghostElementTemplate\"\n  },\n  outputs: {\n    dragPointerDown: \"dragPointerDown\",\n    dragStart: \"dragStart\",\n    ghostElementCreated: \"ghostElementCreated\",\n    dragging: \"dragging\",\n    dragEnd: \"dragEnd\"\n  },\n  features: [ɵngcc0.ɵɵNgOnChangesFeature]\n});\n/** @nocollapse */\n\nDraggableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: DraggableScrollContainerDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }];\n};\n\nDraggableDirective.propDecorators = {\n  dropData: [{\n    type: Input\n  }],\n  dragAxis: [{\n    type: Input\n  }],\n  dragSnapGrid: [{\n    type: Input\n  }],\n  ghostDragEnabled: [{\n    type: Input\n  }],\n  showOriginalElementWhileDragging: [{\n    type: Input\n  }],\n  validateDrag: [{\n    type: Input\n  }],\n  dragCursor: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  ghostElementAppendTo: [{\n    type: Input\n  }],\n  ghostElementTemplate: [{\n    type: Input\n  }],\n  dragPointerDown: [{\n    type: Output\n  }],\n  dragStart: [{\n    type: Output\n  }],\n  ghostElementCreated: [{\n    type: Output\n  }],\n  dragging: [{\n    type: Output\n  }],\n  dragEnd: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DraggableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDraggable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }];\n  }, {\n    dragAxis: [{\n      type: Input\n    }],\n    dragSnapGrid: [{\n      type: Input\n    }],\n    ghostDragEnabled: [{\n      type: Input\n    }],\n    showOriginalElementWhileDragging: [{\n      type: Input\n    }],\n    dragCursor: [{\n      type: Input\n    }],\n    dragPointerDown: [{\n      type: Output\n    }],\n    dragStart: [{\n      type: Output\n    }],\n    ghostElementCreated: [{\n      type: Output\n    }],\n    dragging: [{\n      type: Output\n    }],\n    dragEnd: [{\n      type: Output\n    }],\n    dropData: [{\n      type: Input\n    }],\n    validateDrag: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }],\n    ghostElementAppendTo: [{\n      type: Input\n    }],\n    ghostElementTemplate: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} clientX\n * @param {?} clientY\n * @param {?} rect\n * @return {?}\n */\n\n\nfunction isCoordinateWithinRectangle(clientX, clientY, rect) {\n  return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n}\n\nvar DroppableDirective = /*#__PURE__*/function () {\n  /**\n   * @param {?} element\n   * @param {?} draggableHelper\n   * @param {?} zone\n   * @param {?} renderer\n   * @param {?} scrollContainer\n   */\n  function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {\n    _classCallCheck(this, DroppableDirective);\n\n    this.element = element;\n    this.draggableHelper = draggableHelper;\n    this.zone = zone;\n    this.renderer = renderer;\n    this.scrollContainer = scrollContainer;\n    /**\n     * Called when a draggable element starts overlapping the element\n     */\n\n    this.dragEnter = new EventEmitter();\n    /**\n     * Called when a draggable element stops overlapping the element\n     */\n\n    this.dragLeave = new EventEmitter();\n    /**\n     * Called when a draggable element is moved over the element\n     */\n\n    this.dragOver = new EventEmitter();\n    /**\n     * Called when a draggable element is dropped on this element\n     */\n\n    this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(DroppableDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      var _this8 = this;\n\n      this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      /**\n      * @param {?} drag$\n      * @return {?}\n      */\n      function (drag$) {\n        _this8.renderer.addClass(_this8.element.nativeElement, _this8.dragActiveClass);\n        /** @type {?} */\n\n\n        var droppableElement = {\n          updateCache: true\n        };\n        /** @type {?} */\n\n        var deregisterScrollListener = _this8.renderer.listen(_this8.scrollContainer ? _this8.scrollContainer.elementRef.nativeElement : 'window', 'scroll',\n        /**\n        * @return {?}\n        */\n        function () {\n          droppableElement.updateCache = true;\n        });\n        /** @type {?} */\n\n\n        var currentDragDropData;\n        /** @type {?} */\n\n        var overlaps$ = drag$.pipe(map(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref11) {\n          var clientX = _ref11.clientX,\n              clientY = _ref11.clientY,\n              dropData = _ref11.dropData;\n          currentDragDropData = dropData;\n\n          if (droppableElement.updateCache) {\n            droppableElement.rect = _this8.element.nativeElement.getBoundingClientRect();\n\n            if (_this8.scrollContainer) {\n              droppableElement.scrollContainerRect = _this8.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n            }\n\n            droppableElement.updateCache = false;\n          }\n          /** @type {?} */\n\n\n          var isWithinElement = isCoordinateWithinRectangle(clientX, clientY,\n          /** @type {?} */\n          droppableElement.rect);\n\n          if (droppableElement.scrollContainerRect) {\n            return isWithinElement && isCoordinateWithinRectangle(clientX, clientY,\n            /** @type {?} */\n            droppableElement.scrollContainerRect);\n          } else {\n            return isWithinElement;\n          }\n        }));\n        /** @type {?} */\n\n        var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n        /** @type {?} */\n\n        var dragOverActive;\n        overlapsChanged$.pipe(filter(\n        /**\n        * @param {?} overlapsNow\n        * @return {?}\n        */\n        function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          dragOverActive = true;\n\n          _this8.renderer.addClass(_this8.element.nativeElement, _this8.dragOverClass);\n\n          _this8.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this8.dragEnter.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlaps$.pipe(filter(\n        /**\n        * @param {?} overlapsNow\n        * @return {?}\n        */\n        function (overlapsNow) {\n          return overlapsNow;\n        })).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this8.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this8.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        overlapsChanged$.pipe(pairwise(), filter(\n        /**\n        * @param {?} __0\n        * @return {?}\n        */\n        function (_ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n              didOverlap = _ref13[0],\n              overlapsNow = _ref13[1];\n\n          return didOverlap && !overlapsNow;\n        })).subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          dragOverActive = false;\n\n          _this8.renderer.removeClass(_this8.element.nativeElement, _this8.dragOverClass);\n\n          _this8.zone.run(\n          /**\n          * @return {?}\n          */\n          function () {\n            _this8.dragLeave.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n        drag$.subscribe({\n          complete:\n          /**\n          * @return {?}\n          */\n          function complete() {\n            deregisterScrollListener();\n\n            _this8.renderer.removeClass(_this8.element.nativeElement, _this8.dragActiveClass);\n\n            if (dragOverActive) {\n              _this8.renderer.removeClass(_this8.element.nativeElement, _this8.dragOverClass);\n\n              _this8.zone.run(\n              /**\n              * @return {?}\n              */\n              function () {\n                _this8.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      });\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      if (this.currentDragSubscription) {\n        this.currentDragSubscription.unsubscribe();\n      }\n    }\n  }]);\n\n  return DroppableDirective;\n}();\n\nDroppableDirective.ɵfac = function DroppableDirective_Factory(t) {\n  return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DraggableScrollContainerDirective, 8));\n};\n\nDroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: DroppableDirective,\n  selectors: [[\"\", \"mwlDroppable\", \"\"]],\n  inputs: {\n    dragOverClass: \"dragOverClass\",\n    dragActiveClass: \"dragActiveClass\"\n  },\n  outputs: {\n    dragEnter: \"dragEnter\",\n    dragLeave: \"dragLeave\",\n    dragOver: \"dragOver\",\n    drop: \"drop\"\n  }\n});\n/** @nocollapse */\n\nDroppableDirective.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: DraggableHelper\n  }, {\n    type: NgZone\n  }, {\n    type: Renderer2\n  }, {\n    type: DraggableScrollContainerDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }];\n};\n\nDroppableDirective.propDecorators = {\n  dragOverClass: [{\n    type: Input\n  }],\n  dragActiveClass: [{\n    type: Input\n  }],\n  dragEnter: [{\n    type: Output\n  }],\n  dragLeave: [{\n    type: Output\n  }],\n  dragOver: [{\n    type: Output\n  }],\n  drop: [{\n    type: Output\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[mwlDroppable]'\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: DraggableHelper\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc0.Renderer2\n    }, {\n      type: DraggableScrollContainerDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    dragEnter: [{\n      type: Output\n    }],\n    dragLeave: [{\n      type: Output\n    }],\n    dragOver: [{\n      type: Output\n    }],\n    drop: [{\n      type: Output\n    }],\n    dragOverClass: [{\n      type: Input\n    }],\n    dragActiveClass: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DragAndDropModule = function DragAndDropModule() {\n  _classCallCheck(this, DragAndDropModule);\n};\n\nDragAndDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: DragAndDropModule\n});\nDragAndDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  }\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DragAndDropModule, {\n    declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n    exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n  });\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DragAndDropModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective],\n      exports: [DraggableDirective, DroppableDirective, DraggableScrollContainerDirective]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DragAndDropModule, DraggableHelper as ɵc, DraggableScrollContainerDirective as ɵd, DraggableDirective as ɵb, DroppableDirective as ɵa };","map":{"version":3,"sources":["angular-draggable-droppable/lib/draggable-helper.provider.ts","angular-draggable-droppable/lib/draggable-scroll-container.directive.ts","angular-draggable-droppable/lib/draggable.directive.ts","angular-draggable-droppable/lib/droppable.directive.ts","angular-draggable-droppable/lib/drag-and-drop.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from 'rxjs';\nimport { Injectable } from '@angular/core';\n\nexport interface CurrentDragData {\n  clientX: number;\n  clientY: number;\n  dropData: any;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DraggableHelper {\n  currentDrag = new Subject<Subject<CurrentDragData>>();\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnInit,\n  Renderer2\n} from '@angular/core';\n\n/**\n * If the window isn't scrollable, then place this on the scrollable container that draggable elements are inside. e.g.\n * ```html\n  <div style=\"overflow: scroll\" mwlDraggableScrollContainer>\n    <div mwlDraggable>Drag me!</div>\n  </div>\n  ```\n */\n@Directive({\n  selector: '[mwlDraggableScrollContainer]'\n})\nexport class DraggableScrollContainerDirective implements OnInit {\n  /**\n   * Trigger the DragStart after a long touch in scrollable container when true\n   */\n  @Input()\n  activeLongPressDrag: boolean = false;\n\n  /**\n   * Configuration of a long touch\n   * Duration in ms of a long touch before activating DragStart\n   * Delta of the\n   */\n  @Input()\n  longPressConfig = { duration: 300, delta: 30 };\n\n  private cancelledScroll = false;\n\n  /**\n   * @hidden\n   */\n  constructor(\n    public elementRef: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private zone: NgZone\n  ) {}\n\n  ngOnInit() {\n    this.zone.runOutsideAngular(() => {\n      this.renderer.listen(\n        this.elementRef.nativeElement,\n        'touchmove',\n        (event: TouchEvent) => {\n          if (this.cancelledScroll && event.cancelable) {\n            event.preventDefault();\n          }\n        }\n      );\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  disableScroll(): void {\n    this.cancelledScroll = true;\n    this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'hidden');\n  }\n\n  /**\n   * @hidden\n   */\n  enableScroll(): void {\n    this.cancelledScroll = false;\n    this.renderer.setStyle(this.elementRef.nativeElement, 'overflow', 'auto');\n  }\n\n  /**\n   * @hidden\n   */\n  hasScrollbar(): boolean {\n    const containerHasHorizontalScroll =\n      this.elementRef.nativeElement.scrollWidth -\n        this.elementRef.nativeElement.clientWidth >\n      0;\n    const containerHasVerticalScroll =\n      this.elementRef.nativeElement.scrollHeight -\n        this.elementRef.nativeElement.clientHeight >\n      0;\n    return containerHasHorizontalScroll || containerHasVerticalScroll;\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  Renderer2,\n  Output,\n  EventEmitter,\n  Input,\n  OnDestroy,\n  OnChanges,\n  NgZone,\n  SimpleChanges,\n  Inject,\n  TemplateRef,\n  ViewContainerRef,\n  Optional\n} from '@angular/core';\nimport {\n  Subject,\n  Observable,\n  merge,\n  ReplaySubject,\n  combineLatest,\n  animationFrameScheduler\n} from 'rxjs';\nimport {\n  map,\n  mergeMap,\n  takeUntil,\n  take,\n  takeLast,\n  pairwise,\n  share,\n  filter,\n  count,\n  startWith,\n  auditTime\n} from 'rxjs/operators';\nimport { CurrentDragData, DraggableHelper } from './draggable-helper.provider';\nimport { DOCUMENT } from '@angular/common';\nimport autoScroll from 'dom-autoscroller';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\nexport interface Coordinates {\n  x: number;\n  y: number;\n}\n\nexport interface DragAxis {\n  x: boolean;\n  y: boolean;\n}\n\nexport interface SnapGrid {\n  x?: number;\n  y?: number;\n}\n\nexport interface DragPointerDownEvent extends Coordinates {}\n\nexport interface DragStartEvent {\n  cancelDrag$: ReplaySubject<void>;\n}\n\nexport interface DragMoveEvent extends Coordinates {}\n\nexport interface DragEndEvent extends Coordinates {\n  dragCancelled: boolean;\n}\n\nexport interface ValidateDragParams extends Coordinates {\n  transform: {\n    x: number;\n    y: number;\n  };\n}\n\nexport type ValidateDrag = (params: ValidateDragParams) => boolean;\n\nexport interface PointerEvent {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\nexport interface TimeLongPress {\n  timerBegin: number;\n  timerEnd: number;\n}\n\nexport interface GhostElementCreatedEvent {\n  clientX: number;\n  clientY: number;\n  element: HTMLElement;\n}\n\n@Directive({\n  selector: '[mwlDraggable]'\n})\nexport class DraggableDirective implements OnInit, OnChanges, OnDestroy {\n  /**\n   * an object of data you can pass to the drop event\n   */\n  @Input()\n  dropData: any;\n\n  /**\n   * The axis along which the element is draggable\n   */\n  @Input()\n  dragAxis: DragAxis = { x: true, y: true };\n\n  /**\n   * Snap all drags to an x / y grid\n   */\n  @Input()\n  dragSnapGrid: SnapGrid = {};\n\n  /**\n   * Show a ghost element that shows the drag when dragging\n   */\n  @Input()\n  ghostDragEnabled: boolean = true;\n\n  /**\n   * Show the original element when ghostDragEnabled is true\n   */\n  @Input()\n  showOriginalElementWhileDragging: boolean = false;\n\n  /**\n   * Allow custom behaviour to control when the element is dragged\n   */\n  @Input()\n  validateDrag: ValidateDrag;\n\n  /**\n   * The cursor to use when hovering over a draggable element\n   */\n  @Input()\n  dragCursor: string = '';\n\n  /**\n   * The css class to apply when the element is being dragged\n   */\n  @Input()\n  dragActiveClass: string;\n\n  /**\n   * The element the ghost element will be appended to. Default is next to the dragged element\n   */\n  @Input()\n  ghostElementAppendTo: HTMLElement;\n\n  /**\n   * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.\n   */\n  @Input()\n  ghostElementTemplate: TemplateRef<any>;\n\n  /**\n   * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it\n   */\n  @Output()\n  dragPointerDown = new EventEmitter<DragPointerDownEvent>();\n\n  /**\n   * Called when the element has started to be dragged.\n   * Only called after at least one mouse or touch move event.\n   * If you call $event.cancelDrag$.emit() it will cancel the current drag\n   */\n  @Output()\n  dragStart = new EventEmitter<DragStartEvent>();\n\n  /**\n   * Called after the ghost element has been created\n   */\n  @Output()\n  ghostElementCreated = new EventEmitter<GhostElementCreatedEvent>();\n\n  /**\n   * Called when the element is being dragged\n   */\n  @Output()\n  dragging = new EventEmitter<DragMoveEvent>();\n\n  /**\n   * Called after the element is dragged\n   */\n  @Output()\n  dragEnd = new EventEmitter<DragEndEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerDown$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerMove$ = new Subject<PointerEvent>();\n\n  /**\n   * @hidden\n   */\n  pointerUp$ = new Subject<PointerEvent>();\n\n  private eventListenerSubscriptions: {\n    mousemove?: () => void;\n    mousedown?: () => void;\n    mouseup?: () => void;\n    mouseenter?: () => void;\n    mouseleave?: () => void;\n    touchstart?: () => void;\n    touchmove?: () => void;\n    touchend?: () => void;\n    touchcancel?: () => void;\n  } = {};\n\n  private ghostElement: HTMLElement | null;\n\n  private destroy$ = new Subject();\n\n  private timeLongPress: TimeLongPress = { timerBegin: 0, timerEnd: 0 };\n\n  private scroller: { destroy: () => void };\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private renderer: Renderer2,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private vcr: ViewContainerRef,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective,\n    @Inject(DOCUMENT) private document: any\n  ) {}\n\n  ngOnInit(): void {\n    this.checkEventListeners();\n\n    const pointerDragged$: Observable<any> = this.pointerDown$.pipe(\n      filter(() => this.canDrag()),\n      mergeMap((pointerDownEvent: PointerEvent) => {\n        // fix for https://github.com/mattlewis92/angular-draggable-droppable/issues/61\n        // stop mouse events propagating up the chain\n        if (pointerDownEvent.event.stopPropagation && !this.scrollContainer) {\n          pointerDownEvent.event.stopPropagation();\n        }\n\n        const startScrollPosition = this.getScrollPosition();\n\n        const scrollContainerScroll$ = new Observable(observer => {\n          const scrollContainer = this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window';\n          return this.renderer.listen(scrollContainer, 'scroll', e =>\n            observer.next(e)\n          );\n        }).pipe(\n          startWith(startScrollPosition),\n          map(() => this.getScrollPosition())\n        );\n\n        const currentDrag$ = new Subject<CurrentDragData>();\n        const cancelDrag$ = new ReplaySubject<void>();\n\n        this.zone.run(() => {\n          this.dragPointerDown.next({ x: 0, y: 0 });\n        });\n\n        const dragComplete$ = merge(\n          this.pointerUp$,\n          this.pointerDown$,\n          cancelDrag$,\n          this.destroy$\n        ).pipe(share());\n\n        const pointerMove = combineLatest([\n          this.pointerMove$,\n          scrollContainerScroll$\n        ]).pipe(\n          map(([pointerMoveEvent, scroll]) => {\n            return {\n              currentDrag$,\n              transformX: pointerMoveEvent.clientX - pointerDownEvent.clientX,\n              transformY: pointerMoveEvent.clientY - pointerDownEvent.clientY,\n              clientX: pointerMoveEvent.clientX,\n              clientY: pointerMoveEvent.clientY,\n              scrollLeft: scroll.left,\n              scrollTop: scroll.top\n            };\n          }),\n          map(moveData => {\n            if (this.dragSnapGrid.x) {\n              moveData.transformX =\n                Math.round(moveData.transformX / this.dragSnapGrid.x) *\n                this.dragSnapGrid.x;\n            }\n\n            if (this.dragSnapGrid.y) {\n              moveData.transformY =\n                Math.round(moveData.transformY / this.dragSnapGrid.y) *\n                this.dragSnapGrid.y;\n            }\n\n            return moveData;\n          }),\n          map(moveData => {\n            if (!this.dragAxis.x) {\n              moveData.transformX = 0;\n            }\n\n            if (!this.dragAxis.y) {\n              moveData.transformY = 0;\n            }\n\n            return moveData;\n          }),\n          map(moveData => {\n            const scrollX = moveData.scrollLeft - startScrollPosition.left;\n            const scrollY = moveData.scrollTop - startScrollPosition.top;\n            return {\n              ...moveData,\n              x: moveData.transformX + scrollX,\n              y: moveData.transformY + scrollY\n            };\n          }),\n          filter(\n            ({ x, y, transformX, transformY }) =>\n              !this.validateDrag ||\n              this.validateDrag({\n                x,\n                y,\n                transform: { x: transformX, y: transformY }\n              })\n          ),\n          takeUntil(dragComplete$),\n          share()\n        );\n\n        const dragStarted$ = pointerMove.pipe(\n          take(1),\n          share()\n        );\n        const dragEnded$ = pointerMove.pipe(\n          takeLast(1),\n          share()\n        );\n\n        dragStarted$.subscribe(({ clientX, clientY, x, y }) => {\n          this.zone.run(() => {\n            this.dragStart.next({ cancelDrag$ });\n          });\n\n          this.scroller = autoScroll(\n            [\n              this.scrollContainer\n                ? this.scrollContainer.elementRef.nativeElement\n                : this.document.defaultView\n            ],\n            {\n              margin: 20,\n              autoScroll() {\n                return true;\n              }\n            }\n          );\n\n          this.renderer.addClass(\n            this.element.nativeElement,\n            this.dragActiveClass\n          );\n\n          if (this.ghostDragEnabled) {\n            const rect = this.element.nativeElement.getBoundingClientRect();\n            const clone = this.element.nativeElement.cloneNode(\n              true\n            ) as HTMLElement;\n            if (!this.showOriginalElementWhileDragging) {\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                'hidden'\n              );\n            }\n\n            if (this.ghostElementAppendTo) {\n              this.ghostElementAppendTo.appendChild(clone);\n            } else {\n              this.element.nativeElement.parentNode!.insertBefore(\n                clone,\n                this.element.nativeElement.nextSibling\n              );\n            }\n\n            this.ghostElement = clone;\n\n            document.body.style.cursor = this.dragCursor;\n\n            this.setElementStyles(clone, {\n              position: 'fixed',\n              top: `${rect.top}px`,\n              left: `${rect.left}px`,\n              width: `${rect.width}px`,\n              height: `${rect.height}px`,\n              cursor: this.dragCursor,\n              margin: '0',\n              willChange: 'transform',\n              pointerEvents: 'none'\n            });\n\n            if (this.ghostElementTemplate) {\n              const viewRef = this.vcr.createEmbeddedView(\n                this.ghostElementTemplate\n              );\n              clone.innerHTML = '';\n              viewRef.rootNodes\n                .filter(node => node instanceof Node)\n                .forEach(node => {\n                  clone.appendChild(node);\n                });\n              dragEnded$.subscribe(() => {\n                this.vcr.remove(this.vcr.indexOf(viewRef));\n              });\n            }\n\n            this.zone.run(() => {\n              this.ghostElementCreated.emit({\n                clientX: clientX - x,\n                clientY: clientY - y,\n                element: clone\n              });\n            });\n\n            dragEnded$.subscribe(() => {\n              clone.parentElement!.removeChild(clone);\n              this.ghostElement = null;\n              this.renderer.setStyle(\n                this.element.nativeElement,\n                'visibility',\n                ''\n              );\n            });\n          }\n\n          this.draggableHelper.currentDrag.next(currentDrag$);\n        });\n\n        dragEnded$\n          .pipe(\n            mergeMap(dragEndData => {\n              const dragEndData$ = cancelDrag$.pipe(\n                count(),\n                take(1),\n                map(calledCount => ({\n                  ...dragEndData,\n                  dragCancelled: calledCount > 0\n                }))\n              );\n              cancelDrag$.complete();\n              return dragEndData$;\n            })\n          )\n          .subscribe(({ x, y, dragCancelled }) => {\n            this.scroller.destroy();\n            this.zone.run(() => {\n              this.dragEnd.next({ x, y, dragCancelled });\n            });\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragActiveClass\n            );\n            currentDrag$.complete();\n          });\n\n        const selectionStart$ = new Observable<Event>(observer => {\n          return this.renderer.listen('document', 'selectstart', e =>\n            observer.next(e)\n          );\n        });\n\n        // hack to prevent text getting selected in safari while dragging\n        selectionStart$\n          .pipe(takeUntil(merge(dragComplete$, dragEnded$)))\n          .subscribe(event => {\n            event.preventDefault();\n          });\n\n        return pointerMove;\n      }),\n      share()\n    );\n\n    merge(\n      pointerDragged$.pipe(\n        take(1),\n        map(value => [, value])\n      ),\n      pointerDragged$.pipe(pairwise())\n    )\n      .pipe(\n        filter(([previous, next]) => {\n          if (!previous) {\n            return true;\n          }\n          return previous.x !== next.x || previous.y !== next.y;\n        }),\n        map(([previous, next]) => next),\n        auditTime(0, animationFrameScheduler)\n      )\n      .subscribe(\n        ({ x, y, currentDrag$, clientX, clientY, transformX, transformY }) => {\n          this.zone.run(() => {\n            this.dragging.next({ x, y });\n          });\n          if (this.ghostElement) {\n            const transform = `translate3d(${transformX}px, ${transformY}px, 0px)`;\n            this.setElementStyles(this.ghostElement, {\n              transform,\n              '-webkit-transform': transform,\n              '-ms-transform': transform,\n              '-moz-transform': transform,\n              '-o-transform': transform\n            });\n          }\n          currentDrag$.next({\n            clientX,\n            clientY,\n            dropData: this.dropData\n          });\n        }\n      );\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    if (changes.dragAxis) {\n      this.checkEventListeners();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n    this.pointerDown$.complete();\n    this.pointerMove$.complete();\n    this.pointerUp$.complete();\n    this.destroy$.next();\n  }\n\n  private checkEventListeners(): void {\n    const canDrag: boolean = this.canDrag();\n    const hasEventListeners: boolean =\n      Object.keys(this.eventListenerSubscriptions).length > 0;\n\n    if (canDrag && !hasEventListeners) {\n      this.zone.runOutsideAngular(() => {\n        this.eventListenerSubscriptions.mousedown = this.renderer.listen(\n          this.element.nativeElement,\n          'mousedown',\n          (event: MouseEvent) => {\n            this.onMouseDown(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseup = this.renderer.listen(\n          'document',\n          'mouseup',\n          (event: MouseEvent) => {\n            this.onMouseUp(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchstart = this.renderer.listen(\n          this.element.nativeElement,\n          'touchstart',\n          (event: TouchEvent) => {\n            this.onTouchStart(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchend = this.renderer.listen(\n          'document',\n          'touchend',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.touchcancel = this.renderer.listen(\n          'document',\n          'touchcancel',\n          (event: TouchEvent) => {\n            this.onTouchEnd(event);\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseenter = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseenter',\n          () => {\n            this.onMouseEnter();\n          }\n        );\n\n        this.eventListenerSubscriptions.mouseleave = this.renderer.listen(\n          this.element.nativeElement,\n          'mouseleave',\n          () => {\n            this.onMouseLeave();\n          }\n        );\n      });\n    } else if (!canDrag && hasEventListeners) {\n      this.unsubscribeEventListeners();\n    }\n  }\n\n  private onMouseDown(event: MouseEvent): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove = this.renderer.listen(\n        'document',\n        'mousemove',\n        (mouseMoveEvent: MouseEvent) => {\n          this.pointerMove$.next({\n            event: mouseMoveEvent,\n            clientX: mouseMoveEvent.clientX,\n            clientY: mouseMoveEvent.clientY\n          });\n        }\n      );\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onMouseUp(event: MouseEvent): void {\n    if (this.eventListenerSubscriptions.mousemove) {\n      this.eventListenerSubscriptions.mousemove();\n      delete this.eventListenerSubscriptions.mousemove;\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.clientX,\n      clientY: event.clientY\n    });\n  }\n\n  private onTouchStart(event: TouchEvent): void {\n    if (!this.scrollContainer) {\n      try {\n        event.preventDefault();\n      } catch (e) {}\n    }\n    let hasContainerScrollbar: boolean;\n    let startScrollPosition: any;\n    let isDragActivated: boolean;\n    if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n      this.timeLongPress.timerBegin = Date.now();\n      isDragActivated = false;\n      hasContainerScrollbar = this.scrollContainer.hasScrollbar();\n      startScrollPosition = this.getScrollPosition();\n    }\n    if (!this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove = this.renderer.listen(\n        'document',\n        'touchmove',\n        (touchMoveEvent: TouchEvent) => {\n          if (\n            this.scrollContainer &&\n            this.scrollContainer.activeLongPressDrag &&\n            !isDragActivated &&\n            hasContainerScrollbar\n          ) {\n            isDragActivated = this.shouldBeginDrag(\n              event,\n              touchMoveEvent,\n              startScrollPosition\n            );\n          }\n          if (\n            !this.scrollContainer ||\n            !this.scrollContainer.activeLongPressDrag ||\n            !hasContainerScrollbar ||\n            isDragActivated\n          ) {\n            this.pointerMove$.next({\n              event: touchMoveEvent,\n              clientX: touchMoveEvent.targetTouches[0].clientX,\n              clientY: touchMoveEvent.targetTouches[0].clientY\n            });\n          }\n        }\n      );\n    }\n    this.pointerDown$.next({\n      event,\n      clientX: event.touches[0].clientX,\n      clientY: event.touches[0].clientY\n    });\n  }\n\n  private onTouchEnd(event: TouchEvent): void {\n    if (this.eventListenerSubscriptions.touchmove) {\n      this.eventListenerSubscriptions.touchmove();\n      delete this.eventListenerSubscriptions.touchmove;\n      if (this.scrollContainer && this.scrollContainer.activeLongPressDrag) {\n        this.scrollContainer.enableScroll();\n      }\n    }\n    this.pointerUp$.next({\n      event,\n      clientX: event.changedTouches[0].clientX,\n      clientY: event.changedTouches[0].clientY\n    });\n  }\n\n  private onMouseEnter(): void {\n    this.setCursor(this.dragCursor);\n  }\n\n  private onMouseLeave(): void {\n    this.setCursor('');\n  }\n\n  private canDrag(): boolean {\n    return this.dragAxis.x || this.dragAxis.y;\n  }\n\n  private setCursor(value: string): void {\n    if (!this.eventListenerSubscriptions.mousemove) {\n      this.renderer.setStyle(this.element.nativeElement, 'cursor', value);\n    }\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListenerSubscriptions).forEach(type => {\n      (this as any).eventListenerSubscriptions[type]();\n      delete (this as any).eventListenerSubscriptions[type];\n    });\n  }\n\n  private setElementStyles(\n    element: HTMLElement,\n    styles: { [key: string]: string }\n  ) {\n    Object.keys(styles).forEach(key => {\n      this.renderer.setStyle(element, key, styles[key]);\n    });\n  }\n\n  private getScrollPosition() {\n    if (this.scrollContainer) {\n      return {\n        top: this.scrollContainer.elementRef.nativeElement.scrollTop,\n        left: this.scrollContainer.elementRef.nativeElement.scrollLeft\n      };\n    } else {\n      return {\n        top: window.pageYOffset || document.documentElement.scrollTop,\n        left: window.pageXOffset || document.documentElement.scrollLeft\n      };\n    }\n  }\n\n  private shouldBeginDrag(\n    event: TouchEvent,\n    touchMoveEvent: TouchEvent,\n    startScrollPosition: any\n  ): boolean {\n    const moveScrollPosition = this.getScrollPosition();\n    const deltaScroll = {\n      top: Math.abs(moveScrollPosition.top - startScrollPosition.top),\n      left: Math.abs(moveScrollPosition.left - startScrollPosition.left)\n    };\n    const deltaX =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientX - event.touches[0].clientX\n      ) - deltaScroll.left;\n    const deltaY =\n      Math.abs(\n        touchMoveEvent.targetTouches[0].clientY - event.touches[0].clientY\n      ) - deltaScroll.top;\n    const deltaTotal = deltaX + deltaY;\n    if (\n      deltaTotal > this.scrollContainer.longPressConfig.delta ||\n      deltaScroll.top > 0 ||\n      deltaScroll.left > 0\n    ) {\n      this.timeLongPress.timerBegin = Date.now();\n    }\n    this.timeLongPress.timerEnd = Date.now();\n    const duration =\n      this.timeLongPress.timerEnd - this.timeLongPress.timerBegin;\n    if (duration >= this.scrollContainer.longPressConfig.duration) {\n      this.scrollContainer.disableScroll();\n      return true;\n    }\n    return false;\n  }\n}\n","import {\n  Directive,\n  OnInit,\n  ElementRef,\n  OnDestroy,\n  Output,\n  EventEmitter,\n  NgZone,\n  Input,\n  Renderer2,\n  Optional\n} from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';\nimport { DraggableHelper } from './draggable-helper.provider';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\nfunction isCoordinateWithinRectangle(\n  clientX: number,\n  clientY: number,\n  rect: ClientRect\n): boolean {\n  return (\n    clientX >= rect.left &&\n    clientX <= rect.right &&\n    clientY >= rect.top &&\n    clientY <= rect.bottom\n  );\n}\n\nexport interface DropEvent<T = any> {\n  dropData: T;\n}\n\n@Directive({\n  selector: '[mwlDroppable]'\n})\nexport class DroppableDirective implements OnInit, OnDestroy {\n  /**\n   * Added to the element when an element is dragged over it\n   */\n  @Input()\n  dragOverClass: string;\n\n  /**\n   * Added to the element any time a draggable element is being dragged\n   */\n  @Input()\n  dragActiveClass: string;\n\n  /**\n   * Called when a draggable element starts overlapping the element\n   */\n  @Output()\n  dragEnter = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element stops overlapping the element\n   */\n  @Output()\n  dragLeave = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is moved over the element\n   */\n  @Output()\n  dragOver = new EventEmitter<DropEvent>();\n\n  /**\n   * Called when a draggable element is dropped on this element\n   */\n  @Output()\n  drop = new EventEmitter<DropEvent>(); // tslint:disable-line no-output-named-after-standard-event\n\n  currentDragSubscription: Subscription;\n\n  constructor(\n    private element: ElementRef<HTMLElement>,\n    private draggableHelper: DraggableHelper,\n    private zone: NgZone,\n    private renderer: Renderer2,\n    @Optional() private scrollContainer: DraggableScrollContainerDirective\n  ) {}\n\n  ngOnInit() {\n    this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe(\n      drag$ => {\n        this.renderer.addClass(\n          this.element.nativeElement,\n          this.dragActiveClass\n        );\n        const droppableElement: {\n          rect?: ClientRect;\n          updateCache: boolean;\n          scrollContainerRect?: ClientRect;\n        } = {\n          updateCache: true\n        };\n\n        const deregisterScrollListener = this.renderer.listen(\n          this.scrollContainer\n            ? this.scrollContainer.elementRef.nativeElement\n            : 'window',\n          'scroll',\n          () => {\n            droppableElement.updateCache = true;\n          }\n        );\n\n        let currentDragDropData: any;\n        const overlaps$ = drag$.pipe(\n          map(({ clientX, clientY, dropData }) => {\n            currentDragDropData = dropData;\n            if (droppableElement.updateCache) {\n              droppableElement.rect = this.element.nativeElement.getBoundingClientRect();\n              if (this.scrollContainer) {\n                droppableElement.scrollContainerRect = this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();\n              }\n              droppableElement.updateCache = false;\n            }\n            const isWithinElement = isCoordinateWithinRectangle(\n              clientX,\n              clientY,\n              droppableElement.rect as ClientRect\n            );\n            if (droppableElement.scrollContainerRect) {\n              return (\n                isWithinElement &&\n                isCoordinateWithinRectangle(\n                  clientX,\n                  clientY,\n                  droppableElement.scrollContainerRect as ClientRect\n                )\n              );\n            } else {\n              return isWithinElement;\n            }\n          })\n        );\n\n        const overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());\n\n        let dragOverActive: boolean; // TODO - see if there's a way of doing this via rxjs\n\n        overlapsChanged$\n          .pipe(filter(overlapsNow => overlapsNow))\n          .subscribe(() => {\n            dragOverActive = true;\n            this.renderer.addClass(\n              this.element.nativeElement,\n              this.dragOverClass\n            );\n            this.zone.run(() => {\n              this.dragEnter.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        overlaps$.pipe(filter(overlapsNow => overlapsNow)).subscribe(() => {\n          this.zone.run(() => {\n            this.dragOver.next({\n              dropData: currentDragDropData\n            });\n          });\n        });\n\n        overlapsChanged$\n          .pipe(\n            pairwise(),\n            filter(([didOverlap, overlapsNow]) => didOverlap && !overlapsNow)\n          )\n          .subscribe(() => {\n            dragOverActive = false;\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragOverClass\n            );\n            this.zone.run(() => {\n              this.dragLeave.next({\n                dropData: currentDragDropData\n              });\n            });\n          });\n\n        drag$.subscribe({\n          complete: () => {\n            deregisterScrollListener();\n            this.renderer.removeClass(\n              this.element.nativeElement,\n              this.dragActiveClass\n            );\n            if (dragOverActive) {\n              this.renderer.removeClass(\n                this.element.nativeElement,\n                this.dragOverClass\n              );\n              this.zone.run(() => {\n                this.drop.next({\n                  dropData: currentDragDropData\n                });\n              });\n            }\n          }\n        });\n      }\n    );\n  }\n\n  ngOnDestroy() {\n    if (this.currentDragSubscription) {\n      this.currentDragSubscription.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { DraggableDirective } from './draggable.directive';\nimport { DroppableDirective } from './droppable.directive';\nimport { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';\n\n@NgModule({\n  declarations: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective\n  ],\n  exports: [\n    DraggableDirective,\n    DroppableDirective,\n    DraggableScrollContainerDirective\n  ]\n})\nexport class DragAndDropModule {}\n"]},"metadata":{},"sourceType":"module"}