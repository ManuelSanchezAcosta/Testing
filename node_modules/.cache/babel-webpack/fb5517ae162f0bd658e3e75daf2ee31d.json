{"ast":null,"code":"import _classCallCheck from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"E:/Source/Sistenet/Testing/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { from } from 'rxjs';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\nimport { associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nexport var AngularFirestoreDocument = /*#__PURE__*/function () {\n  function AngularFirestoreDocument(ref, afs) {\n    _classCallCheck(this, AngularFirestoreDocument);\n\n    this.ref = ref;\n    this.afs = afs;\n  }\n\n  _createClass(AngularFirestoreDocument, [{\n    key: \"set\",\n    value: function set(data, options) {\n      return this.ref.set(data, options);\n    }\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      return this.ref.update(data);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      return this.ref.delete();\n    }\n  }, {\n    key: \"collection\",\n    value: function collection(path, queryFn) {\n      var collectionRef = this.ref.collection(path);\n\n      var _associateQuery = associateQuery(collectionRef, queryFn),\n          ref = _associateQuery.ref,\n          query = _associateQuery.query;\n\n      return new AngularFirestoreCollection(ref, query, this.afs);\n    }\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges() {\n      var scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n      return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      return this.snapshotChanges().pipe(map(function (action) {\n        return action.payload.data();\n      }));\n    }\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n  }]);\n\n  return AngularFirestoreDocument;\n}();","map":{"version":3,"sources":["../../../../../src/firestore/document/document.ts"],"names":[],"mappings":";;AAAA,SAAqB,IAArB,QAAiC,MAAjC;AAEA,SAAS,UAAT,QAA2B,uBAA3B;AACA,SAAS,GAAT,EAAc,SAAd,QAA+B,gBAA/B;AAEA,SAA2B,cAA3B,QAAiD,cAAjD;AACA,SAAS,0BAAT,QAA2C,0BAA3C;AAyBA,WAAa,wBAAb;AAOE,oCAAmB,GAAnB,EAAmD,GAAnD,EAAwE;AAAA;;AAArD,SAAA,GAAA,GAAA,GAAA;AAAgC,SAAA,GAAA,GAAA,GAAA;AAA0B;;AAP/E;AAAA;AAAA,wBAcM,IAdN,EAce,OAdf,EAcmC;AAC/B,aAAO,KAAK,GAAL,CAAS,GAAT,CAAa,IAAb,EAAmB,OAAnB,CAAP;AACD;AAhBH;AAAA;AAAA,2BAsBS,IAtBT,EAsByB;AACrB,aAAO,KAAK,GAAL,CAAS,MAAT,CAAgB,IAAhB,CAAP;AACD;AAxBH;AAAA;AAAA,8BA6BQ;AACJ,aAAO,KAAK,GAAL,CAAS,MAAT,EAAP;AACD;AA/BH;AAAA;AAAA,+BAuC6B,IAvC7B,EAuC2C,OAvC3C,EAuC4D;AACxD,UAAM,aAAa,GAAG,KAAK,GAAL,CAAS,UAAT,CAAoB,IAApB,CAAtB;;AADwD,4BAEjC,cAAc,CAAC,aAAD,EAAgB,OAAhB,CAFmB;AAAA,UAEhD,GAFgD,mBAEhD,GAFgD;AAAA,UAE3C,KAF2C,mBAE3C,KAF2C;;AAGxD,aAAO,IAAI,0BAAJ,CAAkC,GAAlC,EAAuC,KAAvC,EAA8C,KAAK,GAAnD,CAAP;AACD;AA3CH;AAAA;AAAA,sCAgDiB;AACb,UAAM,oBAAoB,GAAG,UAAU,CAAI,KAAK,GAAT,EAAc,KAAK,GAAL,CAAS,UAAT,CAAoB,cAAlC,CAAvC;AACA,aAAO,oBAAoB,CAAC,IAArB,CACL,KAAK,GAAL,CAAS,sBADJ,CAAP;AAGD;AArDH;AAAA;AAAA,mCA0Dc;AACV,aAAO,KAAK,eAAL,GAAuB,IAAvB,CACL,GAAG,CAAC,UAAA,MAAM,EAAG;AACX,eAAO,MAAM,CAAC,OAAP,CAAe,IAAf,EAAP;AACD,OAFE,CADE,CAAP;AAKD;AAhEH;AAAA;AAAA,wBAsEM,OAtEN,EAsEoC;AAChC,aAAO,IAAI,CAAC,KAAK,GAAL,CAAS,GAAT,CAAa,OAAb,CAAD,CAAJ,CAA4B,IAA5B,CACL,SAAS,CAAC,KAAK,GAAL,CAAS,UAAT,CAAoB,aAArB,CADJ,CAAP;AAGD;AA1EH;;AAAA;AAAA","sourcesContent":["import { Observable, from } from 'rxjs';\nimport { DocumentReference, SetOptions, DocumentData, QueryFn, Action, DocumentSnapshot } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport { map, observeOn } from 'rxjs/operators';\n\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport { firestore } from 'firebase/app';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T=DocumentData> {\n\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param ref\n   */\n  constructor(public ref: DocumentReference, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   * @param data\n   * @param options\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   * @param data\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   * @param path\n   * @param queryFn\n   */\n  collection<R=DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path);\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<R>(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      this.afs.keepUnstableUntilFirst\n    )\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   */\n  valueChanges(): Observable<T|undefined> {\n    return this.snapshotChanges().pipe(\n      map(action => {\n        return action.payload.data();\n      })\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   * @param options\n   */\n  get(options?: firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      observeOn(this.afs.schedulers.insideAngular),\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}