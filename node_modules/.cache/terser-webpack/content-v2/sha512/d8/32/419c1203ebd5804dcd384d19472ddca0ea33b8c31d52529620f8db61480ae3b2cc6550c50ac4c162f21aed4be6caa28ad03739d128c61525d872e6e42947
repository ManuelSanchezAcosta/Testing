{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{IbkX:function(t,e,n){\"use strict\";n.d(e,\"b\",function(){return u}),n.d(e,\"a\",function(){return l});var o=n(\"1OyB\"),i=n(\"vuIU\"),r=n(\"8Y7J\"),a=new r.s(\"WindowToken\",\"undefined\"!=typeof window&&window.document?{providedIn:\"root\",factory:function(){return window}}:void 0),s=n(\"XNiG\"),c=n(\"SVse\"),u=function(){var t=function(){function t(e,n){Object(o.a)(this,t),this.document=e,this.window=n,this.copySubject=new s.a,this.copyResponse$=this.copySubject.asObservable(),this.config={}}return Object(i.a)(t,[{key:\"configure\",value:function(t){this.config=t}},{key:\"copy\",value:function(t){if(!this.isSupported||!t)return this.pushCopyResponse({isSuccess:!1,content:t});var e=this.copyFromContent(t);return this.pushCopyResponse(e?{content:t,isSuccess:e}:{isSuccess:!1,content:t})}},{key:\"isTargetValid\",value:function(t){if(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement){if(t.hasAttribute(\"disabled\"))throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');return!0}throw new Error(\"Target should be input or textarea\")}},{key:\"copyFromInputElement\",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];try{this.selectTarget(t);var n=this.copyText();return this.clearSelection(e?t:void 0,this.window),n&&this.isCopySuccessInIE11()}catch(o){return!1}}},{key:\"isCopySuccessInIE11\",value:function(){var t=this.window.clipboardData;return!(t&&t.getData&&!t.getData(\"Text\"))}},{key:\"copyFromContent\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.document.body;if(this.tempTextArea&&!e.contains(this.tempTextArea)&&this.destroy(this.tempTextArea.parentElement),!this.tempTextArea){this.tempTextArea=this.createTempTextArea(this.document,this.window);try{e.appendChild(this.tempTextArea)}catch(o){throw new Error(\"Container should be a Dom element\")}}this.tempTextArea.value=t;var n=this.copyFromInputElement(this.tempTextArea,!1);return this.config.cleanUpAfterCopy&&this.destroy(this.tempTextArea.parentElement),n}},{key:\"destroy\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.document.body;this.tempTextArea&&(t.removeChild(this.tempTextArea),this.tempTextArea=void 0)}},{key:\"selectTarget\",value:function(t){return t.select(),t.setSelectionRange(0,t.value.length),t.value.length}},{key:\"copyText\",value:function(){return this.document.execCommand(\"copy\")}},{key:\"clearSelection\",value:function(t,e){t&&t.focus(),e.getSelection().removeAllRanges()}},{key:\"createTempTextArea\",value:function(t,e){var n,o=\"rtl\"===t.documentElement.getAttribute(\"dir\");return(n=t.createElement(\"textarea\")).style.fontSize=\"12pt\",n.style.border=\"0\",n.style.padding=\"0\",n.style.margin=\"0\",n.style.position=\"absolute\",n.style[o?\"right\":\"left\"]=\"-9999px\",n.style.top=(e.pageYOffset||t.documentElement.scrollTop)+\"px\",n.setAttribute(\"readonly\",\"\"),n}},{key:\"pushCopyResponse\",value:function(t){this.copySubject.next(t)}},{key:\"pushCopyReponse\",value:function(t){this.pushCopyResponse(t)}},{key:\"isSupported\",get:function(){return!!this.document.queryCommandSupported&&!!this.document.queryCommandSupported(\"copy\")&&!!this.window}}]),t}();return t.\\u0275fac=function(e){return new(e||t)(r.fc(c.d),r.fc(a,8))},t.\\u0275prov=r.Ob({token:t,factory:t.\\u0275fac,providedIn:\"root\"}),t.ngInjectableDef=Object(r.W)({factory:function(){return new t(Object(r.Z)(c.d),Object(r.Z)(a,8))},token:t,providedIn:\"root\"}),t}(),l=function(){var t=function t(){Object(o.a)(this,t)};return t.\\u0275mod=r.Qb({type:t}),t.\\u0275inj=r.Pb({factory:function(e){return new(e||t)},imports:[[c.c]]}),t}()},OwLc:function(t,e,n){\"use strict\";n.d(e,\"a\",function(){return i});var o=n(\"8Y7J\"),i=function(){function t(t){this.el=t}return t.prototype.ngAfterViewInit=function(){var t=this;setTimeout(function(){t.matchHeights(t.el.nativeElement,t.matchHeight)},700)},t.prototype.matchHeights=function(t,e){if(t){var n=t.getElementsByClassName(e);if(n){Array.from(n).forEach(function(t){t.style.height=\"initial\"});var o=Array.from(n).map(function(t){return t.getBoundingClientRect().height}).reduce(function(t,e){return e>t?e:t},0);window.innerWidth>1200?Array.from(n).forEach(function(t){return t.style.height=o+\"px\"}):window.innerWidth<1199&&Array.from(n).forEach(function(t){return t.style.height=\"initial\"})}}},t.prototype.onResize=function(){this.matchHeights(this.el.nativeElement,this.matchHeight)},t.\\u0275fac=function(e){return new(e||t)(o.Sb(o.m))},t.\\u0275dir=o.Nb({type:t,selectors:[[\"\",\"matchHeight\",\"\"]],hostBindings:function(t,e){1&t&&o.ic(\"resize\",function(){return e.onResize()},!1,o.Ic)},inputs:{matchHeight:\"matchHeight\"}}),t}()},sJBm:function(t,e,n){var o,i,r;r=this,o=[n(\"uki+\")],void 0===(i=(function(t){return r.returnExportsGlobal=function(t){return function(t,e,n){\"use strict\";var o={currency:void 0,currencyFormatCallback:void 0,tooltipOffset:{x:0,y:-20},anchorToPoint:!1,appendToBody:!1,class:void 0,pointClass:\"ct-point\"};function i(t){var e=new RegExp(\"tooltip-show\\\\s*\",\"gi\");t.className=t.className.replace(e,\"\").trim()}function r(t,e){return(\" \"+t.getAttribute(\"class\")+\" \").indexOf(\" \"+e+\" \")>-1}n.plugins=n.plugins||{},n.plugins.tooltip=function(a){return a=n.extend({},o,a),function(o){var s=a.pointClass;o instanceof n.Bar?s=\"ct-bar\":o instanceof n.Pie&&(s=o.options.donut?\"ct-slice-donut\":\"ct-slice-pie\");var c=o.container,u=c.querySelector(\".chartist-tooltip\");u||((u=e.createElement(\"div\")).className=a.class?\"chartist-tooltip \"+a.class:\"chartist-tooltip\",a.appendToBody?e.body.appendChild(u):c.appendChild(u));var l=u.offsetHeight,p=u.offsetWidth;function f(t,e,n){c.addEventListener(t,function(t){e&&!r(t.target,e)||n(t)})}function h(e){var n,o,i=-(p=p||u.offsetWidth)/2+a.tooltipOffset.x,r=-(l=l||u.offsetHeight)+a.tooltipOffset.y;if(a.appendToBody)u.style.top=e.pageY+r+\"px\",u.style.left=e.pageX+i+\"px\";else{var s=c.getBoundingClientRect(),f=e.pageX-s.left-t.pageXOffset,h=e.pageY-s.top-t.pageYOffset;!0===a.anchorToPoint&&e.target.x2&&e.target.y2&&(n=parseInt(e.target.x2.baseVal.value),o=parseInt(e.target.y2.baseVal.value)),u.style.top=(o||h)+r+\"px\",u.style.left=(n||f)+i+\"px\"}}i(u),f(\"mouseover\",s,function(t){var i,s=t.target,c=\"\",f=(o instanceof n.Pie?s:s.parentNode)?s.parentNode.getAttribute(\"ct:meta\")||s.parentNode.getAttribute(\"ct:series-name\"):\"\",d=s.getAttribute(\"ct:meta\")||f||\"\",m=!!d,y=s.getAttribute(\"ct:value\");if(a.transformTooltipTextFnc&&\"function\"==typeof a.transformTooltipTextFnc&&(y=a.transformTooltipTextFnc(y)),a.tooltipFnc&&\"function\"==typeof a.tooltipFnc)c=a.tooltipFnc(d,y);else{if(a.metaIsHTML){var g=e.createElement(\"textarea\");g.innerHTML=d,d=g.value}if(d='<span class=\"chartist-tooltip-meta\">'+d+\"</span>\",m)c+=d+\"<br>\";else if(o instanceof n.Pie){var v=function(t,e){do{t=t.nextSibling}while(t&&!r(t,\"ct-label\"));return t}(s);v&&(c+=((i=v).innerText||i.textContent)+\"<br>\")}y&&(a.currency&&(y=null!=a.currencyFormatCallback?a.currencyFormatCallback(y,a):a.currency+y.replace(/(\\d)(?=(\\d{3})+(?:\\.\\d+)?$)/g,\"$1,\")),c+=y='<span class=\"chartist-tooltip-value\">'+y+\"</span>\")}c&&(u.innerHTML=c,h(t),function(t){r(t,\"tooltip-show\")||(t.className=t.className+\" tooltip-show\")}(u),l=u.offsetHeight,p=u.offsetWidth)}),f(\"mouseout\",s,function(){i(u)}),f(\"mousemove\",null,function(t){!1===a.anchorToPoint&&h(t)})}}}(window,document,t),t.plugins.tooltips}(t)}).apply(e,o))||(t.exports=i)}}]);","name":"common.cbf3446a2c591f6bdb06.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[0],{\n\n/***/ \"IbkX\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ ngx_clipboard_ClipboardService; });\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ ngx_clipboard_ClipboardModule; });\n\n// UNUSED EXPORTS: ClipboardDirective, ClipboardIfSupportedDirective\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\nvar classCallCheck = __webpack_require__(\"1OyB\");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\nvar createClass = __webpack_require__(\"vuIU\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/fesm2015/core.js + 4 modules\nvar core = __webpack_require__(\"8Y7J\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-window-token/fesm2015/ngx-window-token.js\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\nvar WINDOW = new core[\"s\" /* InjectionToken */]('WindowToken', typeof window !== 'undefined' && window.document ? {\n  providedIn: 'root',\n  factory:\n  /**\r\n  * @return {?}\r\n  */\n  function factory() {\n    return window;\n  }\n} : undefined);\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/fesm2015/common.js\nvar common = __webpack_require__(\"SVse\");\n\n// CONCATENATED MODULE: ./node_modules/ngx-clipboard/fesm2015/ngx-clipboard.js\n\n\n\n\n\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The following code is heavily copied from https://github.com/zenorocha/clipboard.js\n */\n\n\n\nvar ngx_clipboard_ClipboardService = /*@__PURE__*/function () {\n  var ClipboardService = /*#__PURE__*/function () {\n    /**\n     * @param {?} document\n     * @param {?} window\n     */\n    function ClipboardService(document, window) {\n      Object(classCallCheck[\"a\" /* default */])(this, ClipboardService);\n\n      this.document = document;\n      this.window = window;\n      this.copySubject = new Subject[\"a\" /* Subject */]();\n      this.copyResponse$ = this.copySubject.asObservable();\n      this.config = {};\n    }\n    /**\n     * @param {?} config\n     * @return {?}\n     */\n\n\n    Object(createClass[\"a\" /* default */])(ClipboardService, [{\n      key: \"configure\",\n      value: function configure(config) {\n        this.config = config;\n      }\n      /**\n       * @param {?} content\n       * @return {?}\n       */\n\n    }, {\n      key: \"copy\",\n      value: function copy(content) {\n        if (!this.isSupported || !content) {\n          return this.pushCopyResponse({\n            isSuccess: false,\n            content: content\n          });\n        }\n        /** @type {?} */\n\n\n        var copyResult = this.copyFromContent(content);\n\n        if (copyResult) {\n          return this.pushCopyResponse({\n            content: content,\n            isSuccess: copyResult\n          });\n        }\n\n        return this.pushCopyResponse({\n          isSuccess: false,\n          content: content\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"isTargetValid\",\n\n      /**\n       * @param {?} element\n       * @return {?}\n       */\n      value: function isTargetValid(element) {\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n          if (element.hasAttribute('disabled')) {\n            throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n          }\n\n          return true;\n        }\n\n        throw new Error('Target should be input or textarea');\n      }\n      /**\n       * Attempts to copy from an input `targetElm`\n       * @param {?} targetElm\n       * @param {?=} isFocus\n       * @return {?}\n       */\n\n    }, {\n      key: \"copyFromInputElement\",\n      value: function copyFromInputElement(targetElm) {\n        var isFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        try {\n          this.selectTarget(targetElm);\n          /** @type {?} */\n\n          var re = this.copyText();\n          this.clearSelection(isFocus ? targetElm : undefined, this.window);\n          return re && this.isCopySuccessInIE11();\n        } catch (error) {\n          return false;\n        }\n      }\n      /**\n       * This is a hack for IE11 to return `true` even if copy fails.\n       * @return {?}\n       */\n\n    }, {\n      key: \"isCopySuccessInIE11\",\n      value: function isCopySuccessInIE11() {\n        /** @type {?} */\n        var clipboardData = this.window['clipboardData'];\n\n        if (clipboardData && clipboardData.getData) {\n          if (!clipboardData.getData('Text')) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n      /**\n       * Creates a fake textarea element, sets its value from `text` property,\n       * and makes a selection on it.\n       * @param {?} content\n       * @param {?=} container\n       * @return {?}\n       */\n\n    }, {\n      key: \"copyFromContent\",\n      value: function copyFromContent(content) {\n        var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.document.body;\n\n        // check if the temp textarea still belongs to the current container.\n        // In case we have multiple places using ngx-clipboard, one is in a modal using container but the other one is not.\n        if (this.tempTextArea && !container.contains(this.tempTextArea)) {\n          this.destroy(this.tempTextArea.parentElement);\n        }\n\n        if (!this.tempTextArea) {\n          this.tempTextArea = this.createTempTextArea(this.document, this.window);\n\n          try {\n            container.appendChild(this.tempTextArea);\n          } catch (error) {\n            throw new Error('Container should be a Dom element');\n          }\n        }\n\n        this.tempTextArea.value = content;\n        /** @type {?} */\n\n        var toReturn = this.copyFromInputElement(this.tempTextArea, false);\n\n        if (this.config.cleanUpAfterCopy) {\n          this.destroy(this.tempTextArea.parentElement);\n        }\n\n        return toReturn;\n      }\n      /**\n       * Remove temporary textarea if any exists.\n       * @param {?=} container\n       * @return {?}\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.document.body;\n\n        if (this.tempTextArea) {\n          container.removeChild(this.tempTextArea); // removeChild doesn't remove the reference from memory\n\n          this.tempTextArea = undefined;\n        }\n      }\n      /**\n       * Select the target html input element.\n       * @private\n       * @param {?} inputElement\n       * @return {?}\n       */\n\n    }, {\n      key: \"selectTarget\",\n      value: function selectTarget(inputElement) {\n        inputElement.select();\n        inputElement.setSelectionRange(0, inputElement.value.length);\n        return inputElement.value.length;\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"copyText\",\n      value: function copyText() {\n        return this.document.execCommand('copy');\n      }\n      /**\n       * Moves focus away from `target` and back to the trigger, removes current selection.\n       * @private\n       * @param {?} inputElement\n       * @param {?} window\n       * @return {?}\n       */\n\n    }, {\n      key: \"clearSelection\",\n      value: function clearSelection(inputElement, window) {\n        inputElement && inputElement.focus();\n        window.getSelection().removeAllRanges();\n      }\n      /**\n       * Creates a fake textarea for copy command.\n       * @private\n       * @param {?} doc\n       * @param {?} window\n       * @return {?}\n       */\n\n    }, {\n      key: \"createTempTextArea\",\n      value: function createTempTextArea(doc, window) {\n        /** @type {?} */\n        var isRTL = doc.documentElement.getAttribute('dir') === 'rtl';\n        /** @type {?} */\n\n        var ta;\n        ta = doc.createElement('textarea'); // Prevent zooming on iOS\n\n        ta.style.fontSize = '12pt'; // Reset box model\n\n        ta.style.border = '0';\n        ta.style.padding = '0';\n        ta.style.margin = '0'; // Move element out of screen horizontally\n\n        ta.style.position = 'absolute';\n        ta.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n        /** @type {?} */\n\n        var yPosition = window.pageYOffset || doc.documentElement.scrollTop;\n        ta.style.top = yPosition + 'px';\n        ta.setAttribute('readonly', '');\n        return ta;\n      }\n      /**\n       * Pushes copy operation response to copySubject, to provide global access\n       * to the response.\n       * @param {?} response\n       * @return {?}\n       */\n\n    }, {\n      key: \"pushCopyResponse\",\n      value: function pushCopyResponse(response) {\n        this.copySubject.next(response);\n      }\n      /**\n       * @deprecated use pushCopyResponse instead.\n       * @param {?} response\n       * @return {?}\n       */\n\n    }, {\n      key: \"pushCopyReponse\",\n      value: function pushCopyReponse(response) {\n        this.pushCopyResponse(response);\n      }\n    }, {\n      key: \"isSupported\",\n      get: function get() {\n        return !!this.document.queryCommandSupported && !!this.document.queryCommandSupported('copy') && !!this.window;\n      }\n    }]);\n\n    return ClipboardService;\n  }();\n\n  ClipboardService.ɵfac = function ClipboardService_Factory(t) {\n    return new (t || ClipboardService)(core[\"fc\" /* ɵɵinject */](common[\"d\" /* DOCUMENT */]), core[\"fc\" /* ɵɵinject */](WINDOW, 8));\n  };\n\n  ClipboardService.ɵprov = core[\"Ob\" /* ɵɵdefineInjectable */]({\n    token: ClipboardService,\n    factory: ClipboardService.ɵfac,\n    providedIn: 'root'\n  });\n  /** @nocollapse */\n\n  ClipboardService.ngInjectableDef = Object(core[\"W\" /* defineInjectable */])({\n    factory: function ClipboardService_Factory() {\n      return new ClipboardService(Object(core[\"Z\" /* inject */])(common[\"d\" /* DOCUMENT */]), Object(core[\"Z\" /* inject */])(WINDOW, 8));\n    },\n    token: ClipboardService,\n    providedIn: \"root\"\n  });\n  return ClipboardService;\n}();\n\nvar ngx_clipboard_ClipboardDirective = /*@__PURE__*/function () {\n  var ClipboardDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} clipboardSrv\n     */\n    function ClipboardDirective(clipboardSrv) {\n      Object(classCallCheck[\"a\" /* default */])(this, ClipboardDirective);\n\n      this.clipboardSrv = clipboardSrv;\n      this.cbOnSuccess = new core[\"o\" /* EventEmitter */]();\n      this.cbOnError = new core[\"o\" /* EventEmitter */]();\n    } // tslint:disable-next-line:no-empty\n\n    /**\n     * @return {?}\n     */\n\n\n    Object(createClass[\"a\" /* default */])(ClipboardDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {}\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.clipboardSrv.destroy(this.container);\n      }\n      /**\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"onClick\",\n      value: function onClick(event) {\n        if (!this.clipboardSrv.isSupported) {\n          this.handleResult(false, undefined, event);\n        } else if (this.targetElm && this.clipboardSrv.isTargetValid(this.targetElm)) {\n          this.handleResult(this.clipboardSrv.copyFromInputElement(this.targetElm), this.targetElm.value, event);\n        } else if (this.cbContent) {\n          this.handleResult(this.clipboardSrv.copyFromContent(this.cbContent, this.container), this.cbContent, event);\n        }\n      }\n      /**\n       * Fires an event based on the copy operation result.\n       * @private\n       * @param {?} succeeded\n       * @param {?} copiedContent\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"handleResult\",\n      value: function handleResult(succeeded, copiedContent, event) {\n        /** @type {?} */\n        var response = {\n          isSuccess: succeeded,\n          event: event\n        };\n\n        if (succeeded) {\n          response = Object.assign(response, {\n            content: copiedContent,\n            successMessage: this.cbSuccessMsg\n          });\n          this.cbOnSuccess.emit(response);\n        } else {\n          this.cbOnError.emit(response);\n        }\n\n        this.clipboardSrv.pushCopyResponse(response);\n      }\n    }]);\n\n    return ClipboardDirective;\n  }();\n\n  ClipboardDirective.ɵfac = function ClipboardDirective_Factory(t) {\n    return new (t || ClipboardDirective)(core[\"Sb\" /* ɵɵdirectiveInject */](ngx_clipboard_ClipboardService));\n  };\n\n  ClipboardDirective.ɵdir = core[\"Nb\" /* ɵɵdefineDirective */]({\n    type: ClipboardDirective,\n    selectors: [[\"\", \"ngxClipboard\", \"\"]],\n    hostBindings: function ClipboardDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        core[\"ic\" /* ɵɵlistener */](\"click\", function ClipboardDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event.target);\n        });\n      }\n    },\n    inputs: {\n      targetElm: [\"ngxClipboard\", \"targetElm\"],\n      container: \"container\",\n      cbContent: \"cbContent\",\n      cbSuccessMsg: \"cbSuccessMsg\"\n    },\n    outputs: {\n      cbOnSuccess: \"cbOnSuccess\",\n      cbOnError: \"cbOnError\"\n    }\n  });\n  return ClipboardDirective;\n}();\n\nvar ngx_clipboard_ClipboardIfSupportedDirective = /*@__PURE__*/function () {\n  var ClipboardIfSupportedDirective = /*#__PURE__*/function () {\n    /**\n     * @param {?} _clipboardService\n     * @param {?} _viewContainerRef\n     * @param {?} _templateRef\n     */\n    function ClipboardIfSupportedDirective(_clipboardService, _viewContainerRef, _templateRef) {\n      Object(classCallCheck[\"a\" /* default */])(this, ClipboardIfSupportedDirective);\n\n      this._clipboardService = _clipboardService;\n      this._viewContainerRef = _viewContainerRef;\n      this._templateRef = _templateRef;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    Object(createClass[\"a\" /* default */])(ClipboardIfSupportedDirective, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        if (this._clipboardService.isSupported) {\n          this._viewContainerRef.createEmbeddedView(this._templateRef);\n        }\n      }\n    }]);\n\n    return ClipboardIfSupportedDirective;\n  }();\n\n  ClipboardIfSupportedDirective.ɵfac = function ClipboardIfSupportedDirective_Factory(t) {\n    return new (t || ClipboardIfSupportedDirective)(core[\"Sb\" /* ɵɵdirectiveInject */](ngx_clipboard_ClipboardService), core[\"Sb\" /* ɵɵdirectiveInject */](core[\"T\" /* ViewContainerRef */]), core[\"Sb\" /* ɵɵdirectiveInject */](core[\"O\" /* TemplateRef */]));\n  };\n\n  ClipboardIfSupportedDirective.ɵdir = core[\"Nb\" /* ɵɵdefineDirective */]({\n    type: ClipboardIfSupportedDirective,\n    selectors: [[\"\", \"ngxClipboardIfSupported\", \"\"]]\n  });\n  return ClipboardIfSupportedDirective;\n}();\n\nvar ngx_clipboard_ClipboardModule = /*@__PURE__*/function () {\n  var ClipboardModule = function ClipboardModule() {\n    Object(classCallCheck[\"a\" /* default */])(this, ClipboardModule);\n  };\n\n  ClipboardModule.ɵmod = core[\"Qb\" /* ɵɵdefineNgModule */]({\n    type: ClipboardModule\n  });\n  ClipboardModule.ɵinj = core[\"Pb\" /* ɵɵdefineInjector */]({\n    factory: function ClipboardModule_Factory(t) {\n      return new (t || ClipboardModule)();\n    },\n    imports: [[common[\"c\" /* CommonModule */]]]\n  });\n  return ClipboardModule;\n}();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Nc\" /* ɵɵsetNgModuleScope */](ngx_clipboard_ClipboardModule, {\n    declarations: function declarations() {\n      return [ngx_clipboard_ClipboardDirective, ngx_clipboard_ClipboardIfSupportedDirective];\n    },\n    imports: function imports() {\n      return [common[\"c\" /* CommonModule */]];\n    },\n    exports: function exports() {\n      return [ngx_clipboard_ClipboardDirective, ngx_clipboard_ClipboardIfSupportedDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\n\n\n/***/ }),\n\n/***/ \"OwLc\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MatchHeightDirective; });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"8Y7J\");\n\r\n\r\nvar MatchHeightDirective = /** @class */ /*@__PURE__*/ (function () {\r\n    function MatchHeightDirective(el) {\r\n        this.el = el;\r\n    }\r\n    MatchHeightDirective.prototype.ngAfterViewInit = function () {\r\n        var _this = this;\r\n        // call our matchHeight function here\r\n        setTimeout(function () {\r\n            _this.matchHeights(_this.el.nativeElement, _this.matchHeight);\r\n        }, 700);\r\n    };\r\n    MatchHeightDirective.prototype.matchHeights = function (parent, className) {\r\n        if (!parent) {\r\n            return;\r\n        }\r\n        // step 1: find all the child elements with the selected class name\r\n        var children = parent.getElementsByClassName(className);\r\n        if (!children) {\r\n            return;\r\n        }\r\n        // Match hight - fix --- comment below code\r\n        Array.from(children).forEach(function (x) {\r\n            x.style.height = 'initial';\r\n        });\r\n        // step 2a: get all the child elements heights\r\n        var itemHeights = Array.from(children).map(function (x) { return x.getBoundingClientRect().height; });\r\n        // step 2b: find out the tallest\r\n        var maxHeight = itemHeights.reduce(function (prev, curr) {\r\n            return curr > prev ? curr : prev;\r\n        }, 0);\r\n        // step 3: update all the child elements to the tallest height\r\n        if (window.innerWidth > 1200) {\r\n            Array.from(children).forEach(function (x) { return (x.style.height = maxHeight + \"px\"); });\r\n        }\r\n        else if (window.innerWidth < 1199) {\r\n            Array.from(children).forEach(function (x) { return (x.style.height = \"initial\"); });\r\n        }\r\n    };\r\n    MatchHeightDirective.prototype.onResize = function () {\r\n        // call our matchHeight function here\r\n        this.matchHeights(this.el.nativeElement, this.matchHeight);\r\n    };\r\n    MatchHeightDirective.ɵfac = function MatchHeightDirective_Factory(t) { return new (t || MatchHeightDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdirectiveInject */ \"Sb\"](_angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ElementRef */ \"m\"])); };\r\n    MatchHeightDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵdefineDirective */ \"Nb\"]({ type: MatchHeightDirective, selectors: [[\"\", \"matchHeight\", \"\"]], hostBindings: function MatchHeightDirective_HostBindings(rf, ctx) {\r\n            if (rf & 1) {\r\n                _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵlistener */ \"ic\"](\"resize\", function MatchHeightDirective_resize_HostBindingHandler() { return ctx.onResize(); }, false, _angular_core__WEBPACK_IMPORTED_MODULE_0__[/* ɵɵresolveWindow */ \"Ic\"]);\r\n            }\r\n        }, inputs: { matchHeight: \"matchHeight\" } });\r\n    return MatchHeightDirective;\r\n}());\r\n\r\n\n\n/***/ }),\n\n/***/ \"sJBm\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(\"uki+\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Chartist) {\n      return root.returnExportsGlobal = factory(Chartist);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function (Chartist) {\n  /**\n   * Chartist.js plugin to display a data label on top of the points in a line chart.\n   *\n   */\n\n  /* global Chartist */\n  (function (window, document, Chartist) {\n    'use strict';\n\n    var defaultOptions = {\n      currency: undefined,\n      currencyFormatCallback: undefined,\n      tooltipOffset: {\n        x: 0,\n        y: -20\n      },\n      anchorToPoint: false,\n      appendToBody: false,\n      class: undefined,\n      pointClass: 'ct-point'\n    };\n    Chartist.plugins = Chartist.plugins || {};\n\n    Chartist.plugins.tooltip = function (options) {\n      options = Chartist.extend({}, defaultOptions, options);\n      return function tooltip(chart) {\n        var tooltipSelector = options.pointClass;\n\n        if (chart instanceof Chartist.Bar) {\n          tooltipSelector = 'ct-bar';\n        } else if (chart instanceof Chartist.Pie) {\n          // Added support for donut graph\n          if (chart.options.donut) {\n            tooltipSelector = 'ct-slice-donut';\n          } else {\n            tooltipSelector = 'ct-slice-pie';\n          }\n        }\n\n        var $chart = chart.container;\n        var $toolTip = $chart.querySelector('.chartist-tooltip');\n\n        if (!$toolTip) {\n          $toolTip = document.createElement('div');\n          $toolTip.className = !options.class ? 'chartist-tooltip' : 'chartist-tooltip ' + options.class;\n\n          if (!options.appendToBody) {\n            $chart.appendChild($toolTip);\n          } else {\n            document.body.appendChild($toolTip);\n          }\n        }\n\n        var height = $toolTip.offsetHeight;\n        var width = $toolTip.offsetWidth;\n        hide($toolTip);\n\n        function on(event, selector, callback) {\n          $chart.addEventListener(event, function (e) {\n            if (!selector || hasClass(e.target, selector)) callback(e);\n          });\n        }\n\n        on('mouseover', tooltipSelector, function (event) {\n          var $point = event.target;\n          var tooltipText = '';\n          var isPieChart = chart instanceof Chartist.Pie ? $point : $point.parentNode;\n          var seriesName = isPieChart ? $point.parentNode.getAttribute('ct:meta') || $point.parentNode.getAttribute('ct:series-name') : '';\n          var meta = $point.getAttribute('ct:meta') || seriesName || '';\n          var hasMeta = !!meta;\n          var value = $point.getAttribute('ct:value');\n\n          if (options.transformTooltipTextFnc && typeof options.transformTooltipTextFnc === 'function') {\n            value = options.transformTooltipTextFnc(value);\n          }\n\n          if (options.tooltipFnc && typeof options.tooltipFnc === 'function') {\n            tooltipText = options.tooltipFnc(meta, value);\n          } else {\n            if (options.metaIsHTML) {\n              var txt = document.createElement('textarea');\n              txt.innerHTML = meta;\n              meta = txt.value;\n            }\n\n            meta = '<span class=\"chartist-tooltip-meta\">' + meta + '</span>';\n\n            if (hasMeta) {\n              tooltipText += meta + '<br>';\n            } else {\n              // For Pie Charts also take the labels into account\n              // Could add support for more charts here as well!\n              if (chart instanceof Chartist.Pie) {\n                var label = next($point, 'ct-label');\n\n                if (label) {\n                  tooltipText += text(label) + '<br>';\n                }\n              }\n            }\n\n            if (value) {\n              if (options.currency) {\n                if (options.currencyFormatCallback != undefined) {\n                  value = options.currencyFormatCallback(value, options);\n                } else {\n                  value = options.currency + value.replace(/(\\d)(?=(\\d{3})+(?:\\.\\d+)?$)/g, '$1,');\n                }\n              }\n\n              value = '<span class=\"chartist-tooltip-value\">' + value + '</span>';\n              tooltipText += value;\n            }\n          }\n\n          if (tooltipText) {\n            $toolTip.innerHTML = tooltipText;\n            setPosition(event);\n            show($toolTip); // Remember height and width to avoid wrong position in IE\n\n            height = $toolTip.offsetHeight;\n            width = $toolTip.offsetWidth;\n          }\n        });\n        on('mouseout', tooltipSelector, function () {\n          hide($toolTip);\n        });\n        on('mousemove', null, function (event) {\n          if (false === options.anchorToPoint) setPosition(event);\n        });\n\n        function setPosition(event) {\n          height = height || $toolTip.offsetHeight;\n          width = width || $toolTip.offsetWidth;\n          var offsetX = -width / 2 + options.tooltipOffset.x;\n          var offsetY = -height + options.tooltipOffset.y;\n          var anchorX, anchorY;\n\n          if (!options.appendToBody) {\n            var box = $chart.getBoundingClientRect();\n            var left = event.pageX - box.left - window.pageXOffset;\n            var top = event.pageY - box.top - window.pageYOffset;\n\n            if (true === options.anchorToPoint && event.target.x2 && event.target.y2) {\n              anchorX = parseInt(event.target.x2.baseVal.value);\n              anchorY = parseInt(event.target.y2.baseVal.value);\n            }\n\n            $toolTip.style.top = (anchorY || top) + offsetY + 'px';\n            $toolTip.style.left = (anchorX || left) + offsetX + 'px';\n          } else {\n            $toolTip.style.top = event.pageY + offsetY + 'px';\n            $toolTip.style.left = event.pageX + offsetX + 'px';\n          }\n        }\n      };\n    };\n\n    function show(element) {\n      if (!hasClass(element, 'tooltip-show')) {\n        element.className = element.className + ' tooltip-show';\n      }\n    }\n\n    function hide(element) {\n      var regex = new RegExp('tooltip-show' + '\\\\s*', 'gi');\n      element.className = element.className.replace(regex, '').trim();\n    }\n\n    function hasClass(element, className) {\n      return (' ' + element.getAttribute('class') + ' ').indexOf(' ' + className + ' ') > -1;\n    }\n\n    function next(element, className) {\n      do {\n        element = element.nextSibling;\n      } while (element && !hasClass(element, className));\n\n      return element;\n    }\n\n    function text(element) {\n      return element.innerText || element.textContent;\n    }\n  })(window, document, Chartist);\n\n  return Chartist.plugins.tooltips;\n});\n\n/***/ })\n\n}]);","inputSourceMap":null}