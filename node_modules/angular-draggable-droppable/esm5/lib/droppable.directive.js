/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef, Output, EventEmitter, NgZone, Input, Renderer2, Optional } from '@angular/core';
import { distinctUntilChanged, pairwise, filter, map } from 'rxjs/operators';
import { DraggableHelper } from './draggable-helper.provider';
import { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';
/**
 * @param {?} clientX
 * @param {?} clientY
 * @param {?} rect
 * @return {?}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './draggable-helper.provider';
import * as ɵngcc2 from './draggable-scroll-container.directive';
function isCoordinateWithinRectangle(clientX, clientY, rect) {
    return (clientX >= rect.left &&
        clientX <= rect.right &&
        clientY >= rect.top &&
        clientY <= rect.bottom);
}
/**
 * @record
 * @template T
 */
export function DropEvent() { }
if (false) {
    /** @type {?} */
    DropEvent.prototype.dropData;
}
var DroppableDirective = /** @class */ (function () {
    function DroppableDirective(element, draggableHelper, zone, renderer, scrollContainer) {
        this.element = element;
        this.draggableHelper = draggableHelper;
        this.zone = zone;
        this.renderer = renderer;
        this.scrollContainer = scrollContainer;
        /**
         * Called when a draggable element starts overlapping the element
         */
        this.dragEnter = new EventEmitter();
        /**
         * Called when a draggable element stops overlapping the element
         */
        this.dragLeave = new EventEmitter();
        /**
         * Called when a draggable element is moved over the element
         */
        this.dragOver = new EventEmitter();
        /**
         * Called when a draggable element is dropped on this element
         */
        this.drop = new EventEmitter(); // tslint:disable-line no-output-named-after-standard-event
    }
    /**
     * @return {?}
     */
    DroppableDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.currentDragSubscription = this.draggableHelper.currentDrag.subscribe((/**
         * @param {?} drag$
         * @return {?}
         */
        function (drag$) {
            _this.renderer.addClass(_this.element.nativeElement, _this.dragActiveClass);
            /** @type {?} */
            var droppableElement = {
                updateCache: true
            };
            /** @type {?} */
            var deregisterScrollListener = _this.renderer.listen(_this.scrollContainer
                ? _this.scrollContainer.elementRef.nativeElement
                : 'window', 'scroll', (/**
             * @return {?}
             */
            function () {
                droppableElement.updateCache = true;
            }));
            /** @type {?} */
            var currentDragDropData;
            /** @type {?} */
            var overlaps$ = drag$.pipe(map((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var clientX = _a.clientX, clientY = _a.clientY, dropData = _a.dropData;
                currentDragDropData = dropData;
                if (droppableElement.updateCache) {
                    droppableElement.rect = _this.element.nativeElement.getBoundingClientRect();
                    if (_this.scrollContainer) {
                        droppableElement.scrollContainerRect = _this.scrollContainer.elementRef.nativeElement.getBoundingClientRect();
                    }
                    droppableElement.updateCache = false;
                }
                /** @type {?} */
                var isWithinElement = isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.rect)));
                if (droppableElement.scrollContainerRect) {
                    return (isWithinElement &&
                        isCoordinateWithinRectangle(clientX, clientY, (/** @type {?} */ (droppableElement.scrollContainerRect))));
                }
                else {
                    return isWithinElement;
                }
            })));
            /** @type {?} */
            var overlapsChanged$ = overlaps$.pipe(distinctUntilChanged());
            /** @type {?} */
            var dragOverActive;
            overlapsChanged$
                .pipe(filter((/**
             * @param {?} overlapsNow
             * @return {?}
             */
            function (overlapsNow) { return overlapsNow; })))
                .subscribe((/**
             * @return {?}
             */
            function () {
                dragOverActive = true;
                _this.renderer.addClass(_this.element.nativeElement, _this.dragOverClass);
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    _this.dragEnter.next({
                        dropData: currentDragDropData
                    });
                }));
            }));
            overlaps$.pipe(filter((/**
             * @param {?} overlapsNow
             * @return {?}
             */
            function (overlapsNow) { return overlapsNow; }))).subscribe((/**
             * @return {?}
             */
            function () {
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    _this.dragOver.next({
                        dropData: currentDragDropData
                    });
                }));
            }));
            overlapsChanged$
                .pipe(pairwise(), filter((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = tslib_1.__read(_a, 2), didOverlap = _b[0], overlapsNow = _b[1];
                return didOverlap && !overlapsNow;
            })))
                .subscribe((/**
             * @return {?}
             */
            function () {
                dragOverActive = false;
                _this.renderer.removeClass(_this.element.nativeElement, _this.dragOverClass);
                _this.zone.run((/**
                 * @return {?}
                 */
                function () {
                    _this.dragLeave.next({
                        dropData: currentDragDropData
                    });
                }));
            }));
            drag$.subscribe({
                complete: (/**
                 * @return {?}
                 */
                function () {
                    deregisterScrollListener();
                    _this.renderer.removeClass(_this.element.nativeElement, _this.dragActiveClass);
                    if (dragOverActive) {
                        _this.renderer.removeClass(_this.element.nativeElement, _this.dragOverClass);
                        _this.zone.run((/**
                         * @return {?}
                         */
                        function () {
                            _this.drop.next({
                                dropData: currentDragDropData
                            });
                        }));
                    }
                })
            });
        }));
    };
    /**
     * @return {?}
     */
    DroppableDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.currentDragSubscription) {
            this.currentDragSubscription.unsubscribe();
        }
    };
    /** @nocollapse */
    DroppableDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DraggableHelper },
        { type: NgZone },
        { type: Renderer2 },
        { type: DraggableScrollContainerDirective, decorators: [{ type: Optional }] }
    ]; };
    DroppableDirective.propDecorators = {
        dragOverClass: [{ type: Input }],
        dragActiveClass: [{ type: Input }],
        dragEnter: [{ type: Output }],
        dragLeave: [{ type: Output }],
        dragOver: [{ type: Output }],
        drop: [{ type: Output }]
    };
DroppableDirective.ɵfac = function DroppableDirective_Factory(t) { return new (t || DroppableDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DraggableHelper), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DraggableScrollContainerDirective, 8)); };
DroppableDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DroppableDirective, selectors: [["", "mwlDroppable", ""]], inputs: { dragOverClass: "dragOverClass", dragActiveClass: "dragActiveClass" }, outputs: { dragEnter: "dragEnter", dragLeave: "dragLeave", dragOver: "dragOver", drop: "drop" } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DroppableDirective, [{
        type: Directive,
        args: [{
                selector: '[mwlDroppable]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.DraggableHelper }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc2.DraggableScrollContainerDirective, decorators: [{
                type: Optional
            }] }]; }, { dragEnter: [{
            type: Output
        }], dragLeave: [{
            type: Output
        }], dragOver: [{
            type: Output
        }], drop: [{
            type: Output
        }], dragOverClass: [{
            type: Input
        }], dragActiveClass: [{
            type: Input
        }] }); })();
    return DroppableDirective;
}());
export { DroppableDirective };
if (false) {
    /**
     * Added to the element when an element is dragged over it
     * @type {?}
     */
    DroppableDirective.prototype.dragOverClass;
    /**
     * Added to the element any time a draggable element is being dragged
     * @type {?}
     */
    DroppableDirective.prototype.dragActiveClass;
    /**
     * Called when a draggable element starts overlapping the element
     * @type {?}
     */
    DroppableDirective.prototype.dragEnter;
    /**
     * Called when a draggable element stops overlapping the element
     * @type {?}
     */
    DroppableDirective.prototype.dragLeave;
    /**
     * Called when a draggable element is moved over the element
     * @type {?}
     */
    DroppableDirective.prototype.dragOver;
    /**
     * Called when a draggable element is dropped on this element
     * @type {?}
     */
    DroppableDirective.prototype.drop;
    /** @type {?} */
    DroppableDirective.prototype.currentDragSubscription;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.draggableHelper;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    DroppableDirective.prototype.scrollContainer;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcHBhYmxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiYW5ndWxhci1kcmFnZ2FibGUtZHJvcHBhYmxlL2xpYi9kcm9wcGFibGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFFVCxVQUFVLEVBRVYsTUFBTSxFQUNOLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLFNBQVMsRUFDVCxRQUFRLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0UsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzlELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzNGO0FBQ0c7QUFBc0I7QUFDaEI7QUFDQTtBQUNKOzs7O0FBSEwsU0FBUywyQkFBMkIsQ0FDbEMsT0FBZSxFQUNmLE9BQWUsRUFDZixJQUFnQjtBQUNmLElBQ0QsT0FBTyxDQUNMLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSTtBQUN4QixRQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSztBQUN6QixRQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsR0FBRztBQUN2QixRQUFJLE9BQU8sSUFBSSxJQUFJLENBQUMsTUFBTSxDQUN2QixDQUFDO0FBQ0osQ0FBQztBQUNEO0FBQ0c7QUFBVztBQUFlO0FBQTdCLCtCQUVDO0FBQ0Q7QUFDWTtBQUNRLElBSmxCLDZCQUFZO0FBQ2Q7QUFFQTtBQUdTLElBdUNQLDRCQUNVLE9BQWdDLEVBQ2hDLGVBQWdDLEVBQ2hDLElBQVksRUFDWixRQUFtQixFQUNQLGVBQWtEO0FBQ3ZFLFFBTFMsWUFBTyxHQUFQLE9BQU8sQ0FBeUI7QUFBQyxRQUNqQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7QUFBQyxRQUNqQyxTQUFJLEdBQUosSUFB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QUFRLElBRFIsdUNBQzBDO0FBQzVDO0FBRUM7QUFDRTtBQUVEO0FBQVEsSUFEUix1Q0FDMEM7QUFDNUM7QUFFQztBQUNFO0FBRUQ7QUFBUSxJQURSLHNDQUN5QztBQUMzQztBQUVDO0FBQ0U7QUFFRDtBQUFRLElBRFIsa0NBQ3FDO0FBQUM7QUFBcUIsSUFFM0QscURBQXNDO0FBQ3hDO0FBQ087QUFDRTtBQUFnQjtBQUFRLElBQTdCLHFDQUF3QztBQUFDO0FBQ3RDO0FBQWlCO0FBQWdCO0FBQ3RDLElBREUsNkNBQXdDO0FBQUM7QUFDdEM7QUFBaUI7QUFDVjtBQUFRLElBRGxCLGtDQUFvQjtBQUFDO0FBQ2xCO0FBQWlCO0FBQ2pCO0FBQVEsSUFEWCxzQ0FBMkI7QUFBQztBQUN6QjtBQUFpQjtBQUFnQjtBQUFRLElBQTVDLDZDQUFzRTtBQUMxRTtBQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBPbkluaXQsXG4gIEVsZW1lbnRSZWYsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIE5nWm9uZSxcbiAgSW5wdXQsXG4gIFJlbmRlcmVyMixcbiAgT3B0aW9uYWxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBwYWlyd2lzZSwgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEcmFnZ2FibGVIZWxwZXIgfSBmcm9tICcuL2RyYWdnYWJsZS1oZWxwZXIucHJvdmlkZXInO1xuaW1wb3J0IHsgRHJhZ2dhYmxlU2Nyb2xsQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9kcmFnZ2FibGUtc2Nyb2xsLWNvbnRhaW5lci5kaXJlY3RpdmUnO1xuXG5mdW5jdGlvbiBpc0Nvb3JkaW5hdGVXaXRoaW5SZWN0YW5nbGUoXG4gIGNsaWVudFg6IG51bWJlcixcbiAgY2xpZW50WTogbnVtYmVyLFxuICByZWN0OiBDbGllbnRSZWN0XG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBjbGllbnRYID49IHJlY3QubGVmdCAmJlxuICAgIGNsaWVudFggPD0gcmVjdC5yaWdodCAmJlxuICAgIGNsaWVudFkgPj0gcmVjdC50b3AgJiZcbiAgICBjbGllbnRZIDw9IHJlY3QuYm90dG9tXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcEV2ZW50PFQgPSBhbnk+IHtcbiAgZHJvcERhdGE6IFQ7XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1ttd2xEcm9wcGFibGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBEcm9wcGFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBBZGRlZCB0byB0aGUgZWxlbWVudCB3aGVuIGFuIGVsZW1lbnQgaXMgZHJhZ2dlZCBvdmVyIGl0XG4gICAqL1xuICBASW5wdXQoKVxuICBkcmFnT3ZlckNsYXNzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFkZGVkIHRvIHRoZSBlbGVtZW50IGFueSB0aW1lIGEgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgYmVpbmcgZHJhZ2dlZFxuICAgKi9cbiAgQElucHV0KClcbiAgZHJhZ0FjdGl2ZUNsYXNzOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgZHJhZ2dhYmxlIGVsZW1lbnQgc3RhcnRzIG92ZXJsYXBwaW5nIHRoZSBlbGVtZW50XG4gICAqL1xuICBAT3V0cHV0KClcbiAgZHJhZ0VudGVyID0gbmV3IEV2ZW50RW1pdHRlcjxEcm9wRXZlbnQ+KCk7XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgZHJhZ2dhYmxlIGVsZW1lbnQgc3RvcHMgb3ZlcmxhcHBpbmcgdGhlIGVsZW1lbnRcbiAgICovXG4gIEBPdXRwdXQoKVxuICBkcmFnTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyPERyb3BFdmVudD4oKTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBkcmFnZ2FibGUgZWxlbWVudCBpcyBtb3ZlZCBvdmVyIHRoZSBlbGVtZW50XG4gICAqL1xuICBAT3V0cHV0KClcbiAgZHJhZ092ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPERyb3BFdmVudD4oKTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBkcmFnZ2FibGUgZWxlbWVudCBpcyBkcm9wcGVkIG9uIHRoaXMgZWxlbWVudFxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGRyb3AgPSBuZXcgRXZlbnRFbWl0dGVyPERyb3BFdmVudD4oKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby1vdXRwdXQtbmFtZWQtYWZ0ZXItc3RhbmRhcmQtZXZlbnRcblxuICBjdXJyZW50RHJhZ1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgcHJpdmF0ZSBkcmFnZ2FibGVIZWxwZXI6IERyYWdnYWJsZUhlbHBlcixcbiAgICBwcml2YXRlIHpvbmU6IE5nWm9uZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBzY3JvbGxDb250YWluZXI6IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZVxuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5jdXJyZW50RHJhZ1N1YnNjcmlwdGlvbiA9IHRoaXMuZHJhZ2dhYmxlSGVscGVyLmN1cnJlbnREcmFnLnN1YnNjcmliZShcbiAgICAgIGRyYWckID0+IHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhcbiAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICB0aGlzLmRyYWdBY3RpdmVDbGFzc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBkcm9wcGFibGVFbGVtZW50OiB7XG4gICAgICAgICAgcmVjdD86IENsaWVudFJlY3Q7XG4gICAgICAgICAgdXBkYXRlQ2FjaGU6IGJvb2xlYW47XG4gICAgICAgICAgc2Nyb2xsQ29udGFpbmVyUmVjdD86IENsaWVudFJlY3Q7XG4gICAgICAgIH0gPSB7XG4gICAgICAgICAgdXBkYXRlQ2FjaGU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBkZXJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihcbiAgICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lclxuICAgICAgICAgICAgPyB0aGlzLnNjcm9sbENvbnRhaW5lci5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnRcbiAgICAgICAgICAgIDogJ3dpbmRvdycsXG4gICAgICAgICAgJ3Njcm9sbCcsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgZHJvcHBhYmxlRWxlbWVudC51cGRhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBjdXJyZW50RHJhZ0Ryb3BEYXRhOiBhbnk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXBzJCA9IGRyYWckLnBpcGUoXG4gICAgICAgICAgbWFwKCh7IGNsaWVudFgsIGNsaWVudFksIGRyb3BEYXRhIH0pID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnREcmFnRHJvcERhdGEgPSBkcm9wRGF0YTtcbiAgICAgICAgICAgIGlmIChkcm9wcGFibGVFbGVtZW50LnVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgIGRyb3BwYWJsZUVsZW1lbnQucmVjdCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBkcm9wcGFibGVFbGVtZW50LnNjcm9sbENvbnRhaW5lclJlY3QgPSB0aGlzLnNjcm9sbENvbnRhaW5lci5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZHJvcHBhYmxlRWxlbWVudC51cGRhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXNXaXRoaW5FbGVtZW50ID0gaXNDb29yZGluYXRlV2l0aGluUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgICAgICBjbGllbnRZLFxuICAgICAgICAgICAgICBkcm9wcGFibGVFbGVtZW50LnJlY3QgYXMgQ2xpZW50UmVjdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChkcm9wcGFibGVFbGVtZW50LnNjcm9sbENvbnRhaW5lclJlY3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBpc1dpdGhpbkVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICBpc0Nvb3JkaW5hdGVXaXRoaW5SZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgICBjbGllbnRYLFxuICAgICAgICAgICAgICAgICAgY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUVsZW1lbnQuc2Nyb2xsQ29udGFpbmVyUmVjdCBhcyBDbGllbnRSZWN0XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlzV2l0aGluRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IG92ZXJsYXBzQ2hhbmdlZCQgPSBvdmVybGFwcyQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcblxuICAgICAgICBsZXQgZHJhZ092ZXJBY3RpdmU6IGJvb2xlYW47IC8vIFRPRE8gLSBzZWUgaWYgdGhlcmUncyBhIHdheSBvZiBkb2luZyB0aGlzIHZpYSByeGpzXG5cbiAgICAgICAgb3ZlcmxhcHNDaGFuZ2VkJFxuICAgICAgICAgIC5waXBlKGZpbHRlcihvdmVybGFwc05vdyA9PiBvdmVybGFwc05vdykpXG4gICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBkcmFnT3ZlckFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICAgdGhpcy5kcmFnT3ZlckNsYXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZHJhZ0VudGVyLm5leHQoe1xuICAgICAgICAgICAgICAgIGRyb3BEYXRhOiBjdXJyZW50RHJhZ0Ryb3BEYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgb3ZlcmxhcHMkLnBpcGUoZmlsdGVyKG92ZXJsYXBzTm93ID0+IG92ZXJsYXBzTm93KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXIubmV4dCh7XG4gICAgICAgICAgICAgIGRyb3BEYXRhOiBjdXJyZW50RHJhZ0Ryb3BEYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3ZlcmxhcHNDaGFuZ2VkJFxuICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgcGFpcndpc2UoKSxcbiAgICAgICAgICAgIGZpbHRlcigoW2RpZE92ZXJsYXAsIG92ZXJsYXBzTm93XSkgPT4gZGlkT3ZlcmxhcCAmJiAhb3ZlcmxhcHNOb3cpXG4gICAgICAgICAgKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgZHJhZ092ZXJBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICB0aGlzLmRyYWdPdmVyQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5kcmFnTGVhdmUubmV4dCh7XG4gICAgICAgICAgICAgICAgZHJvcERhdGE6IGN1cnJlbnREcmFnRHJvcERhdGFcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICBkcmFnJC5zdWJzY3JpYmUoe1xuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBkZXJlZ2lzdGVyU2Nyb2xsTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICB0aGlzLmRyYWdBY3RpdmVDbGFzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChkcmFnT3ZlckFjdGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJDbGFzc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3AubmV4dCh7XG4gICAgICAgICAgICAgICAgICBkcm9wRGF0YTogY3VycmVudERyYWdEcm9wRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RHJhZ1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50RHJhZ1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIl19